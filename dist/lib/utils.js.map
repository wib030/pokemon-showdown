{
  "version": 3,
  "sources": ["../../lib/utils.ts"],
  "sourcesContent": ["/**\n * Utils library\n *\n * Miscellaneous utility functions that don't really have a better place.\n *\n * It'll always be a judgment call whether or not a function goes into a\n * \"catch-all\" library like this, so here are some guidelines:\n *\n * - It must not have any dependencies\n *\n * - It must conceivably have a use in a wide variety of projects, not just\n *   Pok\u00E9mon (if it's Pok\u00E9mon-specific, Dex is probably a good place for it)\n *\n * - A lot of Chat functions are kind of iffy, but I'm going to say for now\n *   that if it's English-specific, it should be left out of here.\n */\n\nexport type Comparable = number | string | boolean | Comparable[] | { reverse: Comparable };\n\n/**\n * Safely converts the passed variable into a string. Unlike `${str}`,\n * String(str), or str.toString(), Utils.getString is guaranteed not to\n * crash.\n *\n * Specifically, the fear with untrusted JSON is an object like:\n *\n *     let a = {\"toString\": \"this is not a function\"};\n *     console.log(`a is ${a}`);\n *\n * This will crash (because a.toString() is not a function). Instead,\n * getString simply returns '' if the passed variable isn't a\n * string or a number.\n */\n\nexport function getString(str: any): string {\n\treturn (typeof str === 'string' || typeof str === 'number') ? `${str}` : '';\n}\n\nexport function escapeRegex(str: string) {\n\treturn str.replace(/[\\\\^$.*+?()[\\]{}|]/g, '\\\\$&');\n}\n\n/**\n * Escapes HTML in a string.\n*/\nexport function escapeHTML(str: string | number) {\n\tif (str === null || str === undefined) return '';\n\treturn `${str}`\n\t\t.replace(/&/g, '&amp;')\n\t\t.replace(/</g, '&lt;')\n\t\t.replace(/>/g, '&gt;')\n\t\t.replace(/\"/g, '&quot;')\n\t\t.replace(/'/g, '&apos;')\n\t\t.replace(/\\//g, '&#x2f;')\n\t\t.replace(/\\n/g, '<br />');\n}\n\n/**\n * Strips HTML from a string.\n */\nexport function stripHTML(htmlContent: string) {\n\tif (!htmlContent) return '';\n\treturn htmlContent.replace(/<[^>]*>/g, '');\n}\n\n/**\n * Maps numbers to their ordinal string.\n */\nexport function formatOrder(place: number) {\n\t// anything between 10 and 20 should always end with -th\n\tlet remainder = place % 100;\n\tif (remainder >= 10 && remainder <= 20) return `${place}th`;\n\n\t// follow standard rules with -st, -nd, -rd, and -th\n\tremainder = place % 10;\n\tif (remainder === 1) return `${place}st`;\n\tif (remainder === 2) return `${place}nd`;\n\tif (remainder === 3) return `${place}rd`;\n\treturn `${place}th`;\n}\n\n/**\n * Visualizes eval output in a slightly more readable form\n */\nexport function visualize(value: any, depth = 0): string {\n\tif (value === undefined) return `undefined`;\n\tif (value === null) return `null`;\n\tif (typeof value === 'number' || typeof value === 'boolean') {\n\t\treturn `${value}`;\n\t}\n\tif (typeof value === 'string') {\n\t\treturn `\"${value}\"`; // NOT ESCAPED\n\t}\n\tif (typeof value === 'symbol') {\n\t\treturn value.toString();\n\t}\n\tif (Array.isArray(value)) {\n\t\tif (depth > 10) return `[array]`;\n\t\treturn `[` + value.map(elem => visualize(elem, depth + 1)).join(`, `) + `]`;\n\t}\n\tif (value instanceof RegExp || value instanceof Date || value instanceof Function) {\n\t\tif (depth && value instanceof Function) return `Function`;\n\t\treturn `${value}`;\n\t}\n\tlet constructor = '';\n\tif (typeof value.constructor?.name === 'string') {\n\t\tconstructor = value.constructor.name;\n\t\tif (constructor === 'Object') constructor = '';\n\t} else {\n\t\tconstructor = 'null';\n\t}\n\t// If it has a toString, try to grab the base class from there\n\t// (This is for Map/Set subclasses like user.auth)\n\tconst baseClass = (value?.toString && /\\[object (.*)\\]/.exec(value.toString())?.[1]) || constructor;\n\n\tswitch (baseClass) {\n\tcase 'Map':\n\t\tif (depth > 2) return `Map`;\n\t\tconst mapped = [...value.entries()].map(\n\t\t\tval => `${visualize(val[0], depth + 1)} => ${visualize(val[1], depth + 1)}`\n\t\t);\n\t\treturn `${constructor} (${value.size}) { ${mapped.join(', ')} }`;\n\tcase 'Set':\n\t\tif (depth > 2) return `Set`;\n\t\treturn `${constructor} (${value.size}) { ${[...value].map(v => visualize(v), depth + 1).join(', ')} }`;\n\t}\n\n\tif (value.toString) {\n\t\ttry {\n\t\t\tconst stringValue = value.toString();\n\t\t\tif (\n\t\t\t\ttypeof stringValue === 'string' &&\n\t\t\t\tstringValue !== '[object Object]' &&\n\t\t\t\tstringValue !== `[object ${constructor}]`\n\t\t\t) {\n\t\t\t\treturn `${constructor}(${stringValue})`;\n\t\t\t}\n\t\t} catch {}\n\t}\n\tlet buf = '';\n\tfor (const key in value) {\n\t\tif (!Object.prototype.hasOwnProperty.call(value, key)) continue;\n\t\tif (depth > 2 || (depth && constructor)) {\n\t\t\tbuf = '...';\n\t\t\tbreak;\n\t\t}\n\t\tif (buf) buf += `, `;\n\t\tlet displayedKey = key;\n\t\tif (!/^[A-Za-z0-9_$]+$/.test(key)) displayedKey = JSON.stringify(key);\n\t\tbuf += `${displayedKey}: ` + visualize(value[key], depth + 1);\n\t}\n\tif (constructor && !buf && constructor !== 'null') return constructor;\n\treturn `${constructor}{${buf}}`;\n}\n\n/**\n * Compares two variables; intended to be used as a smarter comparator.\n * The two variables must be the same type (TypeScript will not check this).\n *\n * - Numbers are sorted low-to-high, use `-val` to reverse\n * - Strings are sorted A to Z case-semi-insensitively, use `{reverse: val}` to reverse\n * - Booleans are sorted true-first (REVERSE of casting to numbers), use `!val` to reverse\n * - Arrays are sorted lexically in the order of their elements\n *\n * In other words: `[num, str]` will be sorted A to Z, `[num, {reverse: str}]` will be sorted Z to A.\n */\nexport function compare(a: Comparable, b: Comparable): number {\n\tif (typeof a === 'number') {\n\t\treturn a - (b as number);\n\t}\n\tif (typeof a === 'string') {\n\t\treturn a.localeCompare(b as string);\n\t}\n\tif (typeof a === 'boolean') {\n\t\treturn (a ? 1 : 2) - (b ? 1 : 2);\n\t}\n\tif (Array.isArray(a)) {\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tconst comparison = compare(a[i], (b as Comparable[])[i]);\n\t\t\tif (comparison) return comparison;\n\t\t}\n\t\treturn 0;\n\t}\n\tif ('reverse' in a) {\n\t\treturn compare((b as { reverse: string }).reverse, a.reverse);\n\t}\n\tthrow new Error(`Passed value ${a} is not comparable`);\n}\n\n/**\n * Sorts an array according to the callback's output on its elements.\n *\n * The callback's output is compared according to `PSUtils.compare`\n * (numbers low to high, strings A-Z, booleans true-first, arrays in order).\n */\nexport function sortBy<T>(array: T[], callback: (a: T) => Comparable): T[];\n/**\n * Sorts an array according to `PSUtils.compare`\n * (numbers low to high, strings A-Z, booleans true-first, arrays in order).\n *\n * Note that array.sort() only works on strings, not numbers, so you'll need\n * this to sort numbers.\n */\nexport function sortBy<T extends Comparable>(array: T[]): T[];\nexport function sortBy<T>(array: T[], callback?: (a: T) => Comparable) {\n\tif (!callback) return (array as any[]).sort(compare);\n\treturn array.sort((a, b) => compare(callback(a), callback(b)));\n}\n\nexport function splitFirst(str: string, delimiter: string | RegExp): [string, string];\nexport function splitFirst(str: string, delimiter: string | RegExp, limit: 2): [string, string, string];\nexport function splitFirst(str: string, delimiter: string | RegExp, limit: 3): [string, string, string, string];\nexport function splitFirst(str: string, delimiter: string | RegExp, limit: number): string[];\n/**\n* Like string.split(delimiter), but only recognizes the first `limit`\n* delimiters (default 1).\n*\n* `\"1 2 3 4\".split(\" \", 2) => [\"1\", \"2\"]`\n*\n* `Utils.splitFirst(\"1 2 3 4\", \" \", 1) => [\"1\", \"2 3 4\"]`\n*\n* Returns an array of length exactly limit + 1.\n*\n*/\nexport function splitFirst(str: string, delimiter: string | RegExp, limit = 1) {\n\tconst splitStr: string[] = [];\n\twhile (splitStr.length < limit) {\n\t\tlet delimiterIndex, delimiterLength;\n\t\tif (typeof delimiter === 'string') {\n\t\t\tdelimiterIndex = str.indexOf(delimiter);\n\t\t\tdelimiterLength = delimiter.length;\n\t\t} else {\n\t\t\tdelimiter.lastIndex = 0;\n\t\t\tconst match = delimiter.exec(str);\n\t\t\tdelimiterIndex = match ? match.index : -1;\n\t\t\tdelimiterLength = match ? match[0].length : 0;\n\t\t}\n\t\tif (delimiterIndex >= 0) {\n\t\t\tsplitStr.push(str.slice(0, delimiterIndex));\n\t\t\tstr = str.slice(delimiterIndex + delimiterLength);\n\t\t} else {\n\t\t\tsplitStr.push(str);\n\t\t\tstr = '';\n\t\t}\n\t}\n\tsplitStr.push(str);\n\treturn splitStr;\n}\n\n/**\n * Template string tag function for escaping HTML\n */\nexport function html(strings: TemplateStringsArray, ...args: any) {\n\tlet buf = strings[0];\n\tlet i = 0;\n\twhile (i < args.length) {\n\t\tbuf += escapeHTML(args[i]);\n\t\tbuf += strings[++i];\n\t}\n\treturn buf;\n}\n\n/**\n * This combines escapeHTML and forceWrap. The combination allows us to use\n * <wbr /> instead of U+200B, which will make sure the word-wrapping hints\n * can't be copy/pasted (which would mess up code).\n */\nexport function escapeHTMLForceWrap(text: string): string {\n\treturn escapeHTML(forceWrap(text)).replace(/\\u200B/g, '<wbr />');\n}\n\n/**\n * HTML doesn't support `word-wrap: break-word` in tables, but sometimes it\n * would be really nice if it did. This emulates `word-wrap: break-word` by\n * manually inserting U+200B to tell long words to wrap.\n */\nexport function forceWrap(text: string): string {\n\treturn text.replace(/[^\\s]{30,}/g, word => {\n\t\tlet lastBreak = 0;\n\t\tlet brokenWord = '';\n\t\tfor (let i = 1; i < word.length; i++) {\n\t\t\tif (i - lastBreak >= 10 || /[^a-zA-Z0-9([{][a-zA-Z0-9]/.test(word.slice(i - 1, i + 1))) {\n\t\t\t\tbrokenWord += word.slice(lastBreak, i) + '\\u200B';\n\t\t\t\tlastBreak = i;\n\t\t\t}\n\t\t}\n\t\tbrokenWord += word.slice(lastBreak);\n\t\treturn brokenWord;\n\t});\n}\n\nexport function shuffle<T>(arr: T[]): T[] {\n\t// In-place shuffle by Fisher-Yates algorithm\n\tfor (let i = arr.length - 1; i > 0; i--) {\n\t\tconst j = Math.floor(Math.random() * (i + 1));\n\t\t[arr[i], arr[j]] = [arr[j], arr[i]];\n\t}\n\treturn arr;\n}\n\nexport function randomElement<T>(arr: T[]): T {\n\tconst i = Math.floor(Math.random() * arr.length);\n\treturn arr[i];\n}\n\n/** Forces num to be an integer (between min and max). */\nexport function clampIntRange(num: any, min?: number, max?: number): number {\n\tif (typeof num !== 'number') num = 0;\n\tnum = Math.floor(num);\n\tif (min !== undefined && num < min) num = min;\n\tif (max !== undefined && num > max) num = max;\n\treturn num;\n}\n\nexport function clearRequireCache(options: { exclude?: string[] } = {}) {\n\tconst excludes = options?.exclude || [];\n\texcludes.push('/node_modules/');\n\n\tfor (const path in require.cache) {\n\t\tif (excludes.some(p => path.includes(p))) continue;\n\t\tconst mod = require.cache[path]; // have to ref to appease ts\n\t\tif (!mod) continue;\n\t\tuncacheModuleTree(mod, excludes);\n\t\tdelete require.cache[path];\n\t}\n}\n\nexport function uncacheModuleTree(mod: NodeJS.Module, excludes: string[]) {\n\tif (!mod.children?.length || excludes.some(p => mod.filename.includes(p))) return;\n\tfor (const [i, child] of mod.children.entries()) {\n\t\tif (excludes.some(p => child.filename.includes(p))) continue;\n\t\tmod.children?.splice(i, 1);\n\t\tuncacheModuleTree(child, excludes);\n\t}\n\tdelete (mod as any).children;\n}\n\nexport function deepClone(obj: any): any {\n\tif (obj === null || typeof obj !== 'object') return obj;\n\tif (Array.isArray(obj)) return obj.map(prop => deepClone(prop));\n\tconst clone = Object.create(Object.getPrototypeOf(obj));\n\tfor (const key of Object.keys(obj)) {\n\t\tclone[key] = deepClone(obj[key]);\n\t}\n\treturn clone;\n}\n\nexport function deepFreeze<T>(obj: T): T {\n\tif (obj === null || typeof obj !== 'object') return obj;\n\t// support objects with reference loops\n\tif (Object.isFrozen(obj)) return obj;\n\n\tObject.freeze(obj);\n\tif (Array.isArray(obj)) {\n\t\tfor (const elem of obj) deepFreeze(elem);\n\t} else {\n\t\tfor (const elem of Object.values(obj)) deepFreeze(elem);\n\t}\n\treturn obj;\n}\n\nexport function levenshtein(s: string, t: string, l: number): number {\n\t// Original levenshtein distance function by James Westgate, turned out to be the fastest\n\tconst d: number[][] = [];\n\n\t// Step 1\n\tconst n = s.length;\n\tconst m = t.length;\n\n\tif (n === 0) return m;\n\tif (m === 0) return n;\n\tif (l && Math.abs(m - n) > l) return Math.abs(m - n);\n\n\t// Create an array of arrays in javascript (a descending loop is quicker)\n\tfor (let i = n; i >= 0; i--) d[i] = [];\n\n\t// Step 2\n\tfor (let i = n; i >= 0; i--) d[i][0] = i;\n\tfor (let j = m; j >= 0; j--) d[0][j] = j;\n\n\t// Step 3\n\tfor (let i = 1; i <= n; i++) {\n\t\tconst si = s.charAt(i - 1);\n\n\t\t// Step 4\n\t\tfor (let j = 1; j <= m; j++) {\n\t\t\t// Check the jagged ld total so far\n\t\t\tif (i === j && d[i][j] > 4) return n;\n\n\t\t\tconst tj = t.charAt(j - 1);\n\t\t\tconst cost = (si === tj) ? 0 : 1; // Step 5\n\n\t\t\t// Calculate the minimum\n\t\t\tlet mi = d[i - 1][j] + 1;\n\t\t\tconst b = d[i][j - 1] + 1;\n\t\t\tconst c = d[i - 1][j - 1] + cost;\n\n\t\t\tif (b < mi) mi = b;\n\t\t\tif (c < mi) mi = c;\n\n\t\t\td[i][j] = mi; // Step 6\n\t\t}\n\t}\n\n\t// Step 7\n\treturn d[n][m];\n}\n\nexport function waitUntil(time: number): Promise<void> {\n\treturn new Promise(resolve => {\n\t\tsetTimeout(() => resolve(), time - Date.now());\n\t});\n}\n\n/** Like parseInt, but returns NaN if the int isn't already in normalized form */\nexport function parseExactInt(str: string): number {\n\tif (!/^-?(0|[1-9][0-9]*)$/.test(str)) return NaN;\n\treturn parseInt(str);\n}\n\n/** formats an array into a series of question marks and adds the elements to an arguments array */\nexport function formatSQLArray(arr: unknown[], args?: unknown[]) {\n\targs?.push(...arr);\n\treturn [...'?'.repeat(arr.length)].join(', ');\n}\n\nexport function bufFromHex(hex: string) {\n\tconst buf = new Uint8Array(Math.ceil(hex.length / 2));\n\tbufWriteHex(buf, hex);\n\treturn buf;\n}\nexport function bufWriteHex(buf: Uint8Array, hex: string, offset = 0) {\n\tconst size = Math.ceil(hex.length / 2);\n\tfor (let i = 0; i < size; i++) {\n\t\tbuf[offset + i] = parseInt(hex.slice(i * 2, i * 2 + 2).padEnd(2, '0'), 16);\n\t}\n}\nexport function bufReadHex(buf: Uint8Array, start = 0, end?: number) {\n\treturn [...buf.slice(start, end)].map(val => val.toString(16).padStart(2, '0')).join('');\n}\n\nexport class Multiset<T> extends Map<T, number> {\n\toverride get(key: T) {\n\t\treturn super.get(key) ?? 0;\n\t}\n\tadd(key: T) {\n\t\tthis.set(key, this.get(key) + 1);\n\t\treturn this;\n\t}\n\tremove(key: T) {\n\t\tconst newValue = this.get(key) - 1;\n\t\tif (newValue <= 0) return this.delete(key);\n\t\tthis.set(key, newValue);\n\t\treturn true;\n\t}\n}\n\n// backwards compatibility\nexport const Utils = {\n\tparseExactInt, waitUntil, html, escapeHTML,\n\tcompare, sortBy, levenshtein,\n\tshuffle, deepClone, deepFreeze, clampIntRange, clearRequireCache,\n\trandomElement, forceWrap, splitFirst,\n\tstripHTML, visualize, getString,\n\tescapeRegex, formatSQLArray,\n\tbufFromHex, bufReadHex, bufWriteHex,\n\tMultiset,\n};\n"],
  "mappings": "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",
  "names": []
}
