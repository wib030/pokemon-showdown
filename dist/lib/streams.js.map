{
  "version": 3,
  "sources": ["../../lib/streams.ts"],
  "sourcesContent": ["/**\n * Streams\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * The Node.js standard library's Streams are really hard to use. This\n * offers a better stream API.\n *\n * Documented in STREAMS.md.\n *\n * @license MIT\n */\n\nconst BUF_SIZE = 65536 * 4;\n\ntype BufferEncoding =\n\t'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'base64' | 'latin1' | 'binary' | 'hex';\n\nexport class ReadStream {\n\tbuf: Buffer;\n\tbufStart: number;\n\tbufEnd: number;\n\tbufCapacity: number;\n\treadSize: number;\n\tatEOF: boolean;\n\terrorBuf: Error[] | null;\n\tencoding: BufferEncoding;\n\tisReadable: boolean;\n\tisWritable: boolean;\n\tnodeReadableStream: NodeJS.ReadableStream | null;\n\tnextPushResolver: (() => void) | null;\n\tnextPush: Promise<void>;\n\tawaitingPush: boolean;\n\n\tconstructor(optionsOrStreamLike: { [k: string]: any } | NodeJS.ReadableStream | string | Buffer = {}) {\n\t\tthis.buf = Buffer.allocUnsafe(BUF_SIZE);\n\t\tthis.bufStart = 0;\n\t\tthis.bufEnd = 0;\n\t\tthis.bufCapacity = BUF_SIZE;\n\t\tthis.readSize = 0;\n\t\tthis.atEOF = false;\n\t\tthis.errorBuf = null;\n\t\tthis.encoding = 'utf8';\n\t\tthis.isReadable = true;\n\t\tthis.isWritable = false;\n\t\tthis.nodeReadableStream = null;\n\t\tthis.nextPushResolver = null;\n\t\tthis.nextPush = new Promise(resolve => {\n\t\t\tthis.nextPushResolver = resolve;\n\t\t});\n\t\tthis.awaitingPush = false;\n\n\t\tlet options: { [k: string]: any };\n\t\tif (typeof optionsOrStreamLike === 'string') {\n\t\t\toptions = { buffer: optionsOrStreamLike };\n\t\t} else if (optionsOrStreamLike instanceof Buffer) {\n\t\t\toptions = { buffer: optionsOrStreamLike };\n\t\t} else if (typeof (optionsOrStreamLike as any)._readableState === 'object') {\n\t\t\toptions = { nodeStream: optionsOrStreamLike as NodeJS.ReadableStream };\n\t\t} else {\n\t\t\toptions = optionsOrStreamLike;\n\t\t}\n\t\tif (options.nodeStream) {\n\t\t\tconst nodeStream: NodeJS.ReadableStream = options.nodeStream;\n\t\t\tthis.nodeReadableStream = nodeStream;\n\t\t\tnodeStream.on('data', data => {\n\t\t\t\tthis.push(data);\n\t\t\t});\n\t\t\tnodeStream.on('end', () => {\n\t\t\t\tthis.pushEnd();\n\t\t\t});\n\n\t\t\toptions.read = function (this: ReadStream, unusedBytes: number) {\n\t\t\t\tthis.nodeReadableStream!.resume();\n\t\t\t};\n\n\t\t\toptions.pause = function (this: ReadStream, unusedBytes: number) {\n\t\t\t\tthis.nodeReadableStream!.pause();\n\t\t\t};\n\t\t}\n\n\t\tif (options.read) this._read = options.read;\n\t\tif (options.pause) this._pause = options.pause;\n\t\tif (options.destroy) this._destroy = options.destroy;\n\t\tif (options.encoding) this.encoding = options.encoding;\n\t\tif (options.buffer !== undefined) {\n\t\t\tthis.push(options.buffer);\n\t\t\tthis.pushEnd();\n\t\t}\n\t}\n\n\tget bufSize() {\n\t\treturn this.bufEnd - this.bufStart;\n\t}\n\n\tmoveBuf() {\n\t\tif (this.bufStart !== this.bufEnd) {\n\t\t\tthis.buf.copy(this.buf, 0, this.bufStart, this.bufEnd);\n\t\t}\n\t\tthis.bufEnd -= this.bufStart;\n\t\tthis.bufStart = 0;\n\t}\n\n\texpandBuf(newCapacity = this.bufCapacity * 2) {\n\t\tconst newBuf = Buffer.allocUnsafe(newCapacity);\n\t\tthis.buf.copy(newBuf, 0, this.bufStart, this.bufEnd);\n\t\tthis.bufEnd -= this.bufStart;\n\t\tthis.bufStart = 0;\n\t\tthis.bufCapacity = newCapacity;\n\t\tthis.buf = newBuf;\n\t}\n\n\tensureCapacity(additionalCapacity: number) {\n\t\tif (this.bufEnd + additionalCapacity <= this.bufCapacity) return;\n\t\tconst capacity = this.bufEnd - this.bufStart + additionalCapacity;\n\t\tif (capacity <= this.bufCapacity) {\n\t\t\treturn this.moveBuf();\n\t\t}\n\t\tlet newCapacity = this.bufCapacity * 2;\n\t\twhile (newCapacity < capacity) newCapacity *= 2;\n\t\tthis.expandBuf(newCapacity);\n\t}\n\n\tpush(buf: Buffer | string, encoding: BufferEncoding = this.encoding) {\n\t\tlet size;\n\t\tif (this.atEOF) return;\n\t\tif (typeof buf === 'string') {\n\t\t\tsize = Buffer.byteLength(buf, encoding);\n\t\t\tthis.ensureCapacity(size);\n\t\t\tthis.buf.write(buf, this.bufEnd);\n\t\t} else {\n\t\t\tsize = buf.length;\n\t\t\tthis.ensureCapacity(size);\n\t\t\tbuf.copy(this.buf, this.bufEnd);\n\t\t}\n\t\tthis.bufEnd += size;\n\t\tif (this.bufSize > this.readSize && size * 2 < this.bufSize) this._pause();\n\t\tthis.resolvePush();\n\t}\n\n\tpushEnd() {\n\t\tthis.atEOF = true;\n\t\tthis.resolvePush();\n\t}\n\n\tpushError(err: Error, recoverable?: boolean) {\n\t\tif (!this.errorBuf) this.errorBuf = [];\n\t\tthis.errorBuf.push(err);\n\t\tif (!recoverable) this.atEOF = true;\n\t\tthis.resolvePush();\n\t}\n\n\treadError() {\n\t\tif (this.errorBuf) {\n\t\t\tconst err = this.errorBuf.shift()!;\n\t\t\tif (!this.errorBuf.length) this.errorBuf = null;\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tpeekError() {\n\t\tif (this.errorBuf) {\n\t\t\tthrow this.errorBuf[0];\n\t\t}\n\t}\n\n\tresolvePush() {\n\t\tif (!this.nextPushResolver) throw new Error(`Push after end of read stream`);\n\t\tthis.nextPushResolver();\n\t\tif (this.atEOF) {\n\t\t\tthis.nextPushResolver = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.nextPush = new Promise(resolve => {\n\t\t\tthis.nextPushResolver = resolve;\n\t\t});\n\t}\n\n\t_read(size = 0): void | Promise<void> {\n\t\tthrow new Error(`ReadStream needs to be subclassed and the _read function needs to be implemented.`);\n\t}\n\n\t_destroy(): void | Promise<void> {}\n\t_pause() {}\n\n\t/**\n\t * Reads until the internal buffer is non-empty. Does nothing if the\n\t * internal buffer is already non-empty.\n\t *\n\t * If `byteCount` is a number, instead read until the internal buffer\n\t * contains at least `byteCount` bytes.\n\t *\n\t * If `byteCount` is `true`, reads even if the internal buffer is\n\t * non-empty.\n\t */\n\tloadIntoBuffer(byteCount: number | null | true = null, readError?: boolean) {\n\t\tthis[readError ? 'readError' : 'peekError']();\n\t\tif (byteCount === 0) return;\n\t\tthis.readSize = Math.max(\n\t\t\tbyteCount === true ? this.bufSize + 1 : byteCount === null ? 1 : byteCount,\n\t\t\tthis.readSize\n\t\t);\n\t\tif (!this.errorBuf && !this.atEOF && this.bufSize < this.readSize) {\n\t\t\tlet bytes: number | null = this.readSize - this.bufSize;\n\t\t\tif (bytes === Infinity || byteCount === null || byteCount === true) bytes = null;\n\t\t\treturn this.doLoad(bytes, readError);\n\t\t}\n\t}\n\n\tasync doLoad(chunkSize?: number | null, readError?: boolean) {\n\t\twhile (!this.errorBuf && !this.atEOF && this.bufSize < this.readSize) {\n\t\t\tif (chunkSize) void this._read(chunkSize);\n\t\t\telse void this._read();\n\t\t\tawait this.nextPush;\n\t\t\tthis[readError ? 'readError' : 'peekError']();\n\t\t}\n\t}\n\n\tpeek(byteCount?: number | null, encoding?: BufferEncoding): string | null | Promise<string | null>;\n\tpeek(encoding: BufferEncoding): string | null | Promise<string | null>;\n\tpeek(byteCount: number | string | null = null, encoding: BufferEncoding = this.encoding) {\n\t\tif (typeof byteCount === 'string') {\n\t\t\tencoding = byteCount as BufferEncoding;\n\t\t\tbyteCount = null;\n\t\t}\n\t\tconst maybeLoad = this.loadIntoBuffer(byteCount);\n\t\tif (maybeLoad) return maybeLoad.then(() => this.peek(byteCount as number, encoding));\n\n\t\tif (!this.bufSize && byteCount !== 0) return null;\n\t\tif (byteCount === null) return this.buf.toString(encoding, this.bufStart, this.bufEnd);\n\t\tif (byteCount > this.bufSize) byteCount = this.bufSize;\n\t\treturn this.buf.toString(encoding, this.bufStart, this.bufStart + byteCount);\n\t}\n\n\tpeekBuffer(byteCount: number | null = null): Buffer | null | Promise<Buffer | null> {\n\t\tconst maybeLoad = this.loadIntoBuffer(byteCount);\n\t\tif (maybeLoad) return maybeLoad.then(() => this.peekBuffer(byteCount));\n\n\t\tif (!this.bufSize && byteCount !== 0) return null;\n\t\tif (byteCount === null) return this.buf.slice(this.bufStart, this.bufEnd);\n\t\tif (byteCount > this.bufSize) byteCount = this.bufSize;\n\t\treturn this.buf.slice(this.bufStart, this.bufStart + byteCount);\n\t}\n\n\tasync read(byteCount?: number | null, encoding?: BufferEncoding): Promise<string | null>;\n\tasync read(encoding: BufferEncoding): Promise<string | null>;\n\tasync read(byteCount: number | string | null = null, encoding: BufferEncoding = this.encoding) {\n\t\tif (typeof byteCount === 'string') {\n\t\t\tencoding = byteCount as BufferEncoding;\n\t\t\tbyteCount = null;\n\t\t}\n\t\tawait this.loadIntoBuffer(byteCount, true);\n\n\t\t// This MUST NOT be awaited: we MUST synchronously clear byteCount after peeking\n\t\t// if the buffer is written to after peek but before clearing the buffer, the write\n\t\t// will be lost forever\n\t\tconst out = this.peek(byteCount, encoding);\n\t\tif (out && typeof out !== 'string') {\n\t\t\tthrow new Error(\"Race condition; you must not read before a previous read has completed\");\n\t\t}\n\n\t\tif (byteCount === null || byteCount >= this.bufSize) {\n\t\t\tthis.bufStart = 0;\n\t\t\tthis.bufEnd = 0;\n\t\t\tthis.readSize = 0;\n\t\t} else {\n\t\t\tthis.bufStart += byteCount;\n\t\t\tthis.readSize -= byteCount;\n\t\t}\n\t\treturn out;\n\t}\n\n\tbyChunk(byteCount?: number | null) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tconst byteStream = this;\n\t\treturn new ObjectReadStream<string>({\n\t\t\tasync read(this: ObjectReadStream<string>) {\n\t\t\t\tconst next = await byteStream.read(byteCount);\n\t\t\t\tif (typeof next === 'string') this.push(next);\n\t\t\t\telse this.pushEnd();\n\t\t\t},\n\t\t});\n\t}\n\n\tbyLine() {\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tconst byteStream = this;\n\t\treturn new ObjectReadStream<string>({\n\t\t\tasync read(this: ObjectReadStream<string>) {\n\t\t\t\tconst next = await byteStream.readLine();\n\t\t\t\tif (typeof next === 'string') this.push(next);\n\t\t\t\telse this.pushEnd();\n\t\t\t},\n\t\t});\n\t}\n\n\tdelimitedBy(delimiter: string) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tconst byteStream = this;\n\t\treturn new ObjectReadStream<string>({\n\t\t\tasync read(this: ObjectReadStream<string>) {\n\t\t\t\tconst next = await byteStream.readDelimitedBy(delimiter);\n\t\t\t\tif (typeof next === 'string') this.push(next);\n\t\t\t\telse this.pushEnd();\n\t\t\t},\n\t\t});\n\t}\n\n\tasync readBuffer(byteCount: number | null = null) {\n\t\tawait this.loadIntoBuffer(byteCount, true);\n\n\t\t// This MUST NOT be awaited: we must synchronously clear the buffer after peeking\n\t\t// (see `read`)\n\t\tconst out = this.peekBuffer(byteCount);\n\t\tif (out && (out as Promise<unknown>).then) {\n\t\t\tthrow new Error(\"Race condition; you must not read before a previous read has completed\");\n\t\t}\n\n\t\tif (byteCount === null || byteCount >= this.bufSize) {\n\t\t\tthis.bufStart = 0;\n\t\t\tthis.bufEnd = 0;\n\t\t} else {\n\t\t\tthis.bufStart += byteCount;\n\t\t}\n\t\treturn out;\n\t}\n\n\tasync indexOf(symbol: string, encoding: BufferEncoding = this.encoding) {\n\t\tlet idx = this.buf.indexOf(symbol, this.bufStart, encoding);\n\t\twhile (!this.atEOF && (idx >= this.bufEnd || idx < 0)) {\n\t\t\tawait this.loadIntoBuffer(true);\n\t\t\tidx = this.buf.indexOf(symbol, this.bufStart, encoding);\n\t\t}\n\t\tif (idx >= this.bufEnd) return -1;\n\t\treturn idx - this.bufStart;\n\t}\n\n\tasync readAll(encoding: BufferEncoding = this.encoding) {\n\t\treturn (await this.read(Infinity, encoding)) || '';\n\t}\n\n\tpeekAll(encoding: BufferEncoding = this.encoding) {\n\t\treturn this.peek(Infinity, encoding);\n\t}\n\n\tasync readDelimitedBy(symbol: string, encoding: BufferEncoding = this.encoding) {\n\t\tif (this.atEOF && !this.bufSize) return null;\n\t\tconst idx = await this.indexOf(symbol, encoding);\n\t\tif (idx < 0) {\n\t\t\treturn this.readAll(encoding);\n\t\t} else {\n\t\t\tconst out = await this.read(idx, encoding);\n\t\t\tthis.bufStart += Buffer.byteLength(symbol, 'utf8');\n\t\t\treturn out;\n\t\t}\n\t}\n\n\tasync readLine(encoding: BufferEncoding = this.encoding) {\n\t\tif (!encoding) throw new Error(`readLine must have an encoding`);\n\t\tlet line = await this.readDelimitedBy('\\n', encoding);\n\t\tif (line?.endsWith('\\r')) line = line.slice(0, -1);\n\t\treturn line;\n\t}\n\n\tdestroy() {\n\t\tthis.atEOF = true;\n\t\tthis.bufStart = 0;\n\t\tthis.bufEnd = 0;\n\t\tif (this.nextPushResolver) this.resolvePush();\n\t\treturn this._destroy();\n\t}\n\n\tasync next(byteCount: number | null = null) {\n\t\tconst value = await this.read(byteCount);\n\t\treturn { value, done: value === null } as { value: string, done: false } | { value: null, done: true };\n\t}\n\n\tasync pipeTo(outStream: WriteStream, options: { noEnd?: boolean } = {}) {\n\t\tlet next;\n\t\twhile ((next = await this.next(), !next.done)) {\n\t\t\tawait outStream.write(next.value);\n\t\t}\n\t\tif (!options.noEnd) return outStream.writeEnd();\n\t}\n}\n\ninterface WriteStreamOptions {\n\tnodeStream?: NodeJS.WritableStream;\n\twrite?: (this: WriteStream, data: string | Buffer) => (Promise<undefined> | undefined | void);\n\twriteEnd?: (this: WriteStream) => Promise<any>;\n}\n\nexport class WriteStream {\n\tisReadable: boolean;\n\tisWritable: true;\n\tencoding: BufferEncoding;\n\tnodeWritableStream: NodeJS.WritableStream | null;\n\tdrainListeners: (() => void)[];\n\n\tconstructor(optionsOrStream: WriteStreamOptions | NodeJS.WritableStream = {}) {\n\t\tthis.isReadable = false;\n\t\tthis.isWritable = true;\n\t\tthis.encoding = 'utf8';\n\t\tthis.nodeWritableStream = null;\n\t\tthis.drainListeners = [];\n\n\t\tlet options: WriteStreamOptions = optionsOrStream as any;\n\t\tif ((options as any)._writableState) {\n\t\t\toptions = { nodeStream: optionsOrStream as NodeJS.WritableStream };\n\t\t}\n\t\tif (options.nodeStream) {\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\n\t\t\tthis.nodeWritableStream = nodeStream;\n\t\t\toptions.write = function (data: string | Buffer) {\n\t\t\t\tconst result = this.nodeWritableStream!.write(data);\n\t\t\t\tif (result !== false) return undefined;\n\t\t\t\tif (!this.drainListeners.length) {\n\t\t\t\t\tthis.nodeWritableStream!.once('drain', () => {\n\t\t\t\t\t\tfor (const listener of this.drainListeners) listener();\n\t\t\t\t\t\tthis.drainListeners = [];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\t// `as () => void` is necessary because TypeScript thinks that it should be a function\n\t\t\t\t\t// that takes an undefined value as its only parameter: `(value: PromiseLike<undefined> | undefined) => void`\n\t\t\t\t\tthis.drainListeners.push(resolve as () => void);\n\t\t\t\t});\n\t\t\t};\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\n\t\t\t\toptions.writeEnd = function () {\n\t\t\t\t\treturn new Promise<void>(resolve => {\n\t\t\t\t\t\tthis.nodeWritableStream!.end(() => resolve());\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (options.write) this._write = options.write;\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\n\t}\n\n\twrite(chunk: Buffer | string): void | Promise<void> {\n\t\treturn this._write(chunk);\n\t}\n\n\twriteLine(chunk: string): void | Promise<void> {\n\t\tif (chunk === null) {\n\t\t\treturn this.writeEnd();\n\t\t}\n\t\treturn this.write(chunk + '\\n');\n\t}\n\n\t_write(chunk: Buffer | string): void | Promise<void> {\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\n\t}\n\n\t_writeEnd(): void | Promise<void> {}\n\n\tasync writeEnd(chunk?: string): Promise<void> {\n\t\tif (chunk) {\n\t\t\tawait this.write(chunk);\n\t\t}\n\t\treturn this._writeEnd();\n\t}\n}\n\nexport class ReadWriteStream extends ReadStream implements WriteStream {\n\toverride isReadable: true;\n\toverride isWritable: true;\n\tnodeWritableStream: NodeJS.WritableStream | null;\n\tdrainListeners: (() => void)[];\n\n\tconstructor(options: AnyObject = {}) {\n\t\tsuper(options);\n\t\tthis.isReadable = true;\n\t\tthis.isWritable = true;\n\t\tthis.nodeWritableStream = null;\n\t\tthis.drainListeners = [];\n\n\t\tif (options.nodeStream) {\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\n\t\t\tthis.nodeWritableStream = nodeStream;\n\t\t\toptions.write = function (data: string | Buffer) {\n\t\t\t\tconst result = this.nodeWritableStream.write(data);\n\t\t\t\tif (result !== false) return undefined;\n\t\t\t\tif (!this.drainListeners.length) {\n\t\t\t\t\tthis.nodeWritableStream.once('drain', () => {\n\t\t\t\t\t\tfor (const listener of this.drainListeners) listener();\n\t\t\t\t\t\tthis.drainListeners = [];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn new Promise(resolve => {\n\t\t\t\t\tthis.drainListeners.push(resolve);\n\t\t\t\t});\n\t\t\t};\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\n\t\t\t\toptions.writeEnd = function () {\n\t\t\t\t\treturn new Promise<void>(resolve => {\n\t\t\t\t\t\tthis.nodeWritableStream.end(() => resolve());\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t\tif (options.write) this._write = options.write;\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\n\t}\n\n\twrite(chunk: Buffer | string): Promise<void> | void {\n\t\treturn this._write(chunk);\n\t}\n\n\twriteLine(chunk: string): Promise<void> | void {\n\t\treturn this.write(chunk + '\\n');\n\t}\n\n\t_write(chunk: Buffer | string): Promise<void> | void {\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\n\t}\n\n\t/**\n\t * In a ReadWriteStream, `_read` does not need to be implemented,\n\t * because it's valid for the read stream buffer to be filled only by\n\t * `_write`.\n\t */\n\toverride _read(size?: number) {}\n\n\t_writeEnd(): void | Promise<void> {}\n\n\tasync writeEnd() {\n\t\treturn this._writeEnd();\n\t}\n}\n\ntype ObjectReadStreamOptions<T> = {\n\tbuffer?: T[],\n\tread?: (this: ObjectReadStream<T>) => void | Promise<void>,\n\tpause?: (this: ObjectReadStream<T>) => void | Promise<void>,\n\tdestroy?: (this: ObjectReadStream<T>) => void | Promise<void>,\n\tnodeStream?: undefined,\n} | {\n\tbuffer?: undefined,\n\tread?: undefined,\n\tpause?: undefined,\n\tdestroy?: undefined,\n\tnodeStream: NodeJS.ReadableStream,\n};\n\nexport class ObjectReadStream<T> {\n\tbuf: T[];\n\treadSize: number;\n\tatEOF: boolean;\n\terrorBuf: Error[] | null;\n\tisReadable: boolean;\n\tisWritable: boolean;\n\tnodeReadableStream: NodeJS.ReadableStream | null;\n\tnextPushResolver: (() => void) | null;\n\tnextPush: Promise<void>;\n\tawaitingPush: boolean;\n\n\tconstructor(optionsOrStreamLike: ObjectReadStreamOptions<T> | NodeJS.ReadableStream | T[] = {}) {\n\t\tthis.buf = [];\n\t\tthis.readSize = 0;\n\t\tthis.atEOF = false;\n\t\tthis.errorBuf = null;\n\t\tthis.isReadable = true;\n\t\tthis.isWritable = false;\n\t\tthis.nodeReadableStream = null;\n\t\tthis.nextPushResolver = null;\n\t\tthis.nextPush = new Promise(resolve => {\n\t\t\tthis.nextPushResolver = resolve;\n\t\t});\n\t\tthis.awaitingPush = false;\n\n\t\tlet options: ObjectReadStreamOptions<T>;\n\t\tif (Array.isArray(optionsOrStreamLike)) {\n\t\t\toptions = { buffer: optionsOrStreamLike };\n\t\t} else if (typeof (optionsOrStreamLike as any)._readableState === 'object') {\n\t\t\toptions = { nodeStream: optionsOrStreamLike as NodeJS.ReadableStream };\n\t\t} else {\n\t\t\toptions = optionsOrStreamLike as ObjectReadStreamOptions<T>;\n\t\t}\n\t\tif ((options as any).nodeStream) {\n\t\t\tconst nodeStream: NodeJS.ReadableStream = (options as any).nodeStream;\n\t\t\tthis.nodeReadableStream = nodeStream;\n\t\t\tnodeStream.on('data', data => {\n\t\t\t\tthis.push(data);\n\t\t\t});\n\t\t\tnodeStream.on('end', () => {\n\t\t\t\tthis.pushEnd();\n\t\t\t});\n\n\t\t\toptions = {\n\t\t\t\tread() {\n\t\t\t\t\tthis.nodeReadableStream!.resume();\n\t\t\t\t},\n\t\t\t\tpause() {\n\t\t\t\t\tthis.nodeReadableStream!.pause();\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (options.read) this._read = options.read;\n\t\tif (options.pause) this._pause = options.pause;\n\t\tif (options.destroy) this._destroy = options.destroy;\n\t\tif (options.buffer !== undefined) {\n\t\t\tthis.buf = options.buffer.slice();\n\t\t\tthis.pushEnd();\n\t\t}\n\t}\n\n\tpush(elem: T) {\n\t\tif (this.atEOF) return;\n\t\tthis.buf.push(elem);\n\t\tif (this.buf.length > this.readSize && this.buf.length >= 16) void this._pause();\n\t\tthis.resolvePush();\n\t}\n\n\tpushEnd() {\n\t\tthis.atEOF = true;\n\t\tthis.resolvePush();\n\t}\n\n\tpushError(err: Error, recoverable?: boolean) {\n\t\tif (!this.errorBuf) this.errorBuf = [];\n\t\tthis.errorBuf.push(err);\n\t\tif (!recoverable) this.atEOF = true;\n\t\tthis.resolvePush();\n\t}\n\n\treadError() {\n\t\tif (this.errorBuf) {\n\t\t\tconst err = this.errorBuf.shift()!;\n\t\t\tif (!this.errorBuf.length) this.errorBuf = null;\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tpeekError() {\n\t\tif (this.errorBuf) {\n\t\t\tthrow this.errorBuf[0];\n\t\t}\n\t}\n\n\tresolvePush() {\n\t\tif (!this.nextPushResolver) throw new Error(`Push after end of read stream`);\n\t\tthis.nextPushResolver();\n\t\tif (this.atEOF) {\n\t\t\tthis.nextPushResolver = null;\n\t\t\treturn;\n\t\t}\n\t\tthis.nextPush = new Promise(resolve => {\n\t\t\tthis.nextPushResolver = resolve;\n\t\t});\n\t}\n\n\t_read(size = 0): void | Promise<void> {\n\t\tthrow new Error(`ReadStream needs to be subclassed and the _read function needs to be implemented.`);\n\t}\n\n\t_destroy(): void | Promise<void> {}\n\t_pause(): void | Promise<void> {}\n\n\tasync loadIntoBuffer(count: number | true = 1, readError?: boolean) {\n\t\tthis[readError ? 'readError' : 'peekError']();\n\t\tif (count === true) count = this.buf.length + 1;\n\t\tif (this.buf.length >= count) return;\n\t\tthis.readSize = Math.max(count, this.readSize);\n\t\twhile (!this.errorBuf && !this.atEOF && this.buf.length < this.readSize) {\n\t\t\tconst readResult = this._read();\n\t\t\tif (readResult) {\n\t\t\t\tawait readResult;\n\t\t\t} else {\n\t\t\t\tawait this.nextPush;\n\t\t\t}\n\t\t\tthis[readError ? 'readError' : 'peekError']();\n\t\t}\n\t}\n\n\tasync peek() {\n\t\tif (this.buf.length) return this.buf[0];\n\t\tawait this.loadIntoBuffer();\n\t\treturn this.buf[0];\n\t}\n\n\tasync read() {\n\t\tif (this.buf.length) return this.buf.shift();\n\t\tawait this.loadIntoBuffer(1, true);\n\t\tif (!this.buf.length) return null;\n\t\treturn this.buf.shift()!;\n\t}\n\n\tasync peekArray(count: number | null = null) {\n\t\tawait this.loadIntoBuffer(count === null ? 1 : count);\n\t\treturn this.buf.slice(0, count === null ? Infinity : count);\n\t}\n\n\tasync readArray(count: number | null = null) {\n\t\tawait this.loadIntoBuffer(count === null ? 1 : count, true);\n\t\tconst out = this.buf.slice(0, count === null ? Infinity : count);\n\t\tthis.buf = this.buf.slice(out.length);\n\t\treturn out;\n\t}\n\n\tasync readAll() {\n\t\tawait this.loadIntoBuffer(Infinity, true);\n\t\tconst out = this.buf;\n\t\tthis.buf = [];\n\t\treturn out;\n\t}\n\n\tasync peekAll() {\n\t\tawait this.loadIntoBuffer(Infinity);\n\t\treturn this.buf.slice();\n\t}\n\n\tdestroy() {\n\t\tthis.atEOF = true;\n\t\tthis.buf = [];\n\t\tthis.resolvePush();\n\t\treturn this._destroy();\n\t}\n\n\t[Symbol.asyncIterator]() { return this; }\n\tasync next() {\n\t\tif (this.buf.length) return { value: this.buf.shift() as T, done: false as const };\n\t\tawait this.loadIntoBuffer(1, true);\n\t\tif (!this.buf.length) return { value: undefined, done: true as const };\n\t\treturn { value: this.buf.shift() as T, done: false as const };\n\t}\n\n\tasync pipeTo(outStream: ObjectWriteStream<T>, options: { noEnd?: boolean } = {}) {\n\t\tlet next;\n\t\twhile ((next = await this.next(), !next.done)) {\n\t\t\tawait outStream.write(next.value);\n\t\t}\n\t\tif (!options.noEnd) return outStream.writeEnd();\n\t}\n}\n\ninterface ObjectWriteStreamOptions<T> {\n\t_writableState?: any;\n\tnodeStream?: NodeJS.WritableStream;\n\twrite?: (this: ObjectWriteStream<T>, data: T) => Promise<any> | undefined;\n\twriteEnd?: (this: ObjectWriteStream<T>) => Promise<any>;\n}\n\nexport class ObjectWriteStream<T> {\n\tisReadable: boolean;\n\tisWritable: true;\n\tnodeWritableStream: NodeJS.WritableStream | null;\n\n\tconstructor(optionsOrStream: ObjectWriteStreamOptions<T> | NodeJS.WritableStream = {}) {\n\t\tthis.isReadable = false;\n\t\tthis.isWritable = true;\n\t\tthis.nodeWritableStream = null;\n\n\t\tlet options: ObjectWriteStreamOptions<T> = optionsOrStream as any;\n\t\tif (options._writableState) {\n\t\t\toptions = { nodeStream: optionsOrStream as NodeJS.WritableStream };\n\t\t}\n\t\tif (options.nodeStream) {\n\t\t\tconst nodeStream: NodeJS.WritableStream = options.nodeStream;\n\t\t\tthis.nodeWritableStream = nodeStream;\n\n\t\t\toptions.write = function (data: T) {\n\t\t\t\tconst result = this.nodeWritableStream!.write(data as unknown as string);\n\t\t\t\tif (result === false) {\n\t\t\t\t\treturn new Promise<void>(resolve => {\n\t\t\t\t\t\tthis.nodeWritableStream!.once('drain', () => {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Prior to Node v10.12.0, attempting to close STDOUT or STDERR will throw\n\t\t\tif (nodeStream !== process.stdout && nodeStream !== process.stderr) {\n\t\t\t\toptions.writeEnd = function () {\n\t\t\t\t\treturn new Promise<void>(resolve => {\n\t\t\t\t\t\tthis.nodeWritableStream!.end(() => resolve());\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\tif (options.write) this._write = options.write;\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\n\t}\n\n\twrite(elem: T | null): void | Promise<void> {\n\t\tif (elem === null) {\n\t\t\treturn this.writeEnd();\n\t\t}\n\t\treturn this._write(elem);\n\t}\n\n\t_write(elem: T): void | Promise<void> {\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\n\t}\n\n\t_writeEnd(): void | Promise<void> {}\n\n\tasync writeEnd(elem?: T): Promise<void> {\n\t\tif (elem !== undefined) {\n\t\t\tawait this.write(elem);\n\t\t}\n\t\treturn this._writeEnd();\n\t}\n}\n\ninterface ObjectReadWriteStreamOptions<T> {\n\tread?: (this: ObjectReadStream<T>) => void | Promise<void>;\n\tpause?: (this: ObjectReadStream<T>) => void | Promise<void>;\n\tdestroy?: (this: ObjectReadStream<T>) => void | Promise<void>;\n\twrite?: (this: ObjectWriteStream<T>, elem: T) => Promise<any> | undefined | void;\n\twriteEnd?: () => Promise<any> | undefined | void;\n}\n\nexport class ObjectReadWriteStream<T> extends ObjectReadStream<T> implements ObjectWriteStream<T> {\n\toverride isReadable: true;\n\toverride isWritable: true;\n\tnodeWritableStream: NodeJS.WritableStream | null;\n\n\tconstructor(options: ObjectReadWriteStreamOptions<T> = {}) {\n\t\tsuper(options);\n\t\tthis.isReadable = true;\n\t\tthis.isWritable = true;\n\t\tthis.nodeWritableStream = null;\n\t\tif (options.write) this._write = options.write;\n\t\tif (options.writeEnd) this._writeEnd = options.writeEnd;\n\t}\n\n\twrite(elem: T): void | Promise<void> {\n\t\treturn this._write(elem);\n\t}\n\n\t_write(elem: T): void | Promise<void> {\n\t\tthrow new Error(`WriteStream needs to be subclassed and the _write function needs to be implemented.`);\n\t}\n\t/** In a ReadWriteStream, _read does not need to be implemented. */\n\toverride _read() {}\n\n\t_writeEnd(): void | Promise<void> {}\n\n\tasync writeEnd() {\n\t\treturn this._writeEnd();\n\t}\n}\n\nexport function readAll(nodeStream: NodeJS.ReadableStream, encoding?: any) {\n\treturn new ReadStream(nodeStream).readAll(encoding);\n}\n\nexport function stdin() {\n\treturn new ReadStream(process.stdin);\n}\n\nexport function stdout() {\n\treturn new WriteStream(process.stdout);\n}\n\nexport function stdpipe(stream: WriteStream | ReadStream | ReadWriteStream) {\n\tconst promises = [];\n\tif ((stream as ReadStream | WriteStream & { pipeTo: undefined }).pipeTo) {\n\t\tpromises.push((stream as ReadStream).pipeTo(stdout()));\n\t}\n\tif ((stream as WriteStream | ReadStream & { write: undefined }).write) {\n\t\tpromises.push(stdin().pipeTo(stream as WriteStream));\n\t}\n\treturn Promise.all(promises);\n}\n"],
  "mappings": "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",
  "names": []
}
