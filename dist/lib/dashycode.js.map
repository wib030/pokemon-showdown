{
  "version": 3,
  "sources": ["../../lib/dashycode.ts"],
  "sourcesContent": ["/**\n * Dashycode!\n *\n * Encodes a string in a restricted string containing only alphanumeric\n * characters and dashes.\n *\n * (The name is a riff on Punycode, which is what I originally wanted\n * to use for this purpose, but it turns out Punycode does not work on\n * arbitrary strings.)\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */\n\nconst CODE_MAP = \"23456789abcdefghijkmnpqrstuvwxyz\";\nconst UNSAFE_MAP = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\n\n// chunk types:\n// 0b00 = 0x0 = block separator (\"wait until next dash\")\n// 0b01 = 0x1 = capitalize\n//   0b1_01 = 0x5 = specify capitalization of next 8 alphabetic chars of safe part (8 more bits)\n//   0b0_01 = 0x1 = short for 0b00000001_1_01 (capitalize first letter of next 8 alpha chars of safe part)\n// 0b10 = 0x2 = ASCII in UNSAFE_MAP (5 more bits)\n// 0b11 = 0x3 = other\n//   0b0_11 = 0x3 = space\n//   0b1_11 = 0x7 = UTF-16 (16 more bits)\n\n/**\n * An object representing a Dashycode bitstream.\n * The stream can be either a read stream or a write stream, but not\n * both simultaneously.\n */\ninterface DashyStream {\n\tcodeBuf: string;\n\tbuf: number;\n\tbufLength: number;\n}\n\nfunction streamWrite(stream: DashyStream, writeBufLength: number, writeBuf: number) {\n\tstream.buf += (writeBuf << stream.bufLength);\n\tstream.bufLength += writeBufLength;\n\twhile (stream.bufLength >= 5) {\n\t\tstream.codeBuf += CODE_MAP.charAt(stream.buf & 0x1F);\n\t\tstream.buf >>= 5;\n\t\tstream.bufLength -= 5;\n\t}\n}\n\nfunction streamGetCode(stream: DashyStream) {\n\tconst buf = stream.codeBuf + CODE_MAP.charAt(stream.buf);\n\n\t// truncate trailing `2`s (0b00000 chunks)\n\tlet end2Len = 0;\n\twhile (buf.charAt(buf.length - 1 - end2Len) === '2') end2Len++;\n\treturn end2Len ? buf.slice(0, -end2Len) : buf;\n}\n\nfunction streamPeek(stream: DashyStream, readLength: number, readMask: number = 0xFFFF >> (16 - readLength)) {\n\twhile (stream.bufLength < readLength && stream.codeBuf.length) {\n\t\tconst next5Bits = CODE_MAP.indexOf(stream.codeBuf.charAt(0));\n\t\tif (next5Bits < 0) throw new Error(\"Invalid character in coded buffer\");\n\t\tstream.codeBuf = stream.codeBuf.slice(1);\n\t\tstream.buf += next5Bits << stream.bufLength;\n\t\tstream.bufLength += 5;\n\t}\n\treturn stream.buf & readMask;\n}\n\nfunction streamRead(stream: DashyStream, readLength: number, readMask: number = 0xFFFF >> (16 - readLength)) {\n\tconst output = streamPeek(stream, readLength, readMask);\n\t// Note: bufLength can go negative! Streams have infinite trailing 0s\n\tstream.buf >>= readLength;\n\tstream.bufLength -= readLength;\n\treturn output;\n}\n\nexport function encode(str: string, allowCaps = false) {\n\tif (!str) return '0--0';\n\tlet safePart = '';\n\tconst unsafeStream: DashyStream = {\n\t\tcodeBuf: '',\n\t\tbuf: 0x0,\n\t\tbufLength: 0,\n\t};\n\tlet isSafe = true;\n\tlet alphaIndex = 0;\n\tlet capBuffer = 0x0;\n\tfor (let i = 0; i < str.length + 1; i++) {\n\t\tlet curCharCode = i !== str.length ? str.charCodeAt(i) : -1;\n\t\tconst isLowercase = (97 <= curCharCode && curCharCode <= 122); // a-z\n\t\tconst isUppercase = (65 <= curCharCode && curCharCode <= 90); // A-Z\n\t\tconst isNumeric = (48 <= curCharCode && curCharCode <= 57); // 0-9\n\t\tif (capBuffer && (\n\t\t\t!(isLowercase || isUppercase || isNumeric) ||\n\t\t\talphaIndex >= 8 ||\n\t\t\ti === str.length\n\t\t)) {\n\t\t\t// flush cap buffer\n\t\t\tif (capBuffer === 0xD) {\n\t\t\t\tstreamWrite(unsafeStream, 3, 0x1);\n\t\t\t} else {\n\t\t\t\tstreamWrite(unsafeStream, 11, capBuffer);\n\t\t\t}\n\t\t\talphaIndex -= 8;\n\t\t\tcapBuffer = 0x0;\n\t\t}\n\t\tif (i === str.length) break;\n\t\tif (isLowercase || isUppercase || isNumeric) {\n\t\t\tif (alphaIndex < 0) throw new Error(\"alphaIndex should be non-negative here\");\n\t\t\tif (!isSafe) {\n\t\t\t\tif (capBuffer) throw new Error(\"capBuffer shouldn't exist here\");\n\t\t\t\tstreamWrite(unsafeStream, 2, 0x0);\n\t\t\t\tisSafe = true;\n\t\t\t}\n\t\t\tif (isUppercase && !allowCaps) {\n\t\t\t\tsafePart += String.fromCharCode(curCharCode + 32);\n\t\t\t\twhile (alphaIndex >= 8) {\n\t\t\t\t\tif (capBuffer) throw new Error(\"capBuffer shouldn't exist here\");\n\t\t\t\t\talphaIndex -= 8;\n\t\t\t\t\tstreamWrite(unsafeStream, 11, 0x5);\n\t\t\t\t}\n\t\t\t\tif (!capBuffer) capBuffer = 0x5;\n\t\t\t\tcapBuffer += 1 << (alphaIndex + 3);\n\t\t\t} else {\n\t\t\t\tsafePart += str.charAt(i);\n\t\t\t}\n\t\t\tif (isUppercase || isLowercase) alphaIndex++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (capBuffer) throw new Error(\"capBuffer shouldn't exist here\");\n\t\talphaIndex = 0;\n\t\tif (isSafe && curCharCode === 32) { // space\n\t\t\tconst nextCharCode = str.charCodeAt(i + 1);\n\t\t\tif ((97 <= nextCharCode && nextCharCode <= 122) || // a-z\n\t\t\t\t(65 <= nextCharCode && nextCharCode <= 90) || // A-Z\n\t\t\t\t(48 <= nextCharCode && nextCharCode <= 57)) { // 0-9\n\t\t\t\tsafePart += '-';\n\t\t\t\tstreamWrite(unsafeStream, 2, 0x0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (isSafe) {\n\t\t\tsafePart += '-';\n\t\t\tisSafe = false;\n\t\t}\n\t\tlet unsafeMapIndex = -1;\n\t\tif (curCharCode === -1) {\n\t\t\tstreamWrite(unsafeStream, 2, 0x0);\n\t\t} else if (curCharCode === 32) { // space\n\t\t\tstreamWrite(unsafeStream, 3, 0x3);\n\t\t} else if ((unsafeMapIndex = UNSAFE_MAP.indexOf(str.charAt(i))) >= 0) {\n\t\t\tcurCharCode = (unsafeMapIndex << 2) + 0x2;\n\t\t\tstreamWrite(unsafeStream, 7, curCharCode);\n\t\t} else {\n\t\t\tcurCharCode = (curCharCode << 3) + 0x7;\n\t\t\tstreamWrite(unsafeStream, 19, curCharCode);\n\t\t}\n\t}\n\tlet unsafePart = streamGetCode(unsafeStream);\n\tif (safePart.startsWith('-')) {\n\t\tsafePart = safePart.slice(1);\n\t\tunsafePart = `${unsafePart}2`;\n\t}\n\tif (safePart.endsWith('-')) {\n\t\tsafePart = safePart.slice(0, -1);\n\t}\n\tif (!safePart) {\n\t\tsafePart = '0';\n\t\tunsafePart = `0${unsafePart}`;\n\t\tif (unsafePart.endsWith('2')) unsafePart = unsafePart.slice(0, -1);\n\t}\n\tif (!unsafePart) return safePart;\n\treturn `${safePart}--${unsafePart}`;\n}\n\nexport function decode(codedStr: string) {\n\tlet str = '';\n\tlet lastDashIndex = codedStr.lastIndexOf('--');\n\tif (lastDashIndex < 0) {\n\t\t// the regular decoder can also handle this case; but this should\n\t\t// be faster\n\t\treturn codedStr.replace(/-/g, ' ');\n\t}\n\tif (codedStr.charAt(lastDashIndex + 2) === '0') {\n\t\tif (!codedStr.startsWith('0') || lastDashIndex !== 1) {\n\t\t\tthrow new Error(\"Invalid Dashycode\");\n\t\t}\n\t\tlastDashIndex -= 1;\n\t\tcodedStr = '--' + codedStr.slice(4);\n\t}\n\tif (codedStr.endsWith('2')) {\n\t\tcodedStr = '-' + codedStr.slice(0, -1);\n\t\tlastDashIndex += 1;\n\t}\n\tconst unsafeStream: DashyStream = {\n\t\tcodeBuf: codedStr.slice(lastDashIndex + 2),\n\t\tbuf: 0x0,\n\t\tbufLength: 0,\n\t};\n\t/**\n\t * Status:\n\t * 1 : awaiting next read\n\t * 0 : assume all-lowercase\n\t * other: 1 followed by n bits, describing the capitalization of the\n\t * next n bits of alphabetic characters\n\t */\n\tlet capBuffer = 1;\n\tfor (let i = 0; i < lastDashIndex + 1; i++) {\n\t\tlet curChar = codedStr.charAt(i);\n\t\tif (curChar !== '-') {\n\t\t\t// safe char\n\t\t\tconst curCharCode = codedStr.charCodeAt(i);\n\t\t\tconst isLowercase = (97 <= curCharCode && curCharCode <= 122); // a-z\n\t\t\tif (isLowercase) {\n\t\t\t\tif (capBuffer === 1) {\n\t\t\t\t\tcapBuffer = 0;\n\t\t\t\t\tif (streamPeek(unsafeStream, 2, 0x3) === 0x1) {\n\t\t\t\t\t\tswitch (streamRead(unsafeStream, 3, 0x7)) {\n\t\t\t\t\t\tcase 0x5:\n\t\t\t\t\t\t\tcapBuffer = streamRead(unsafeStream, 8, 0xFF) + 0x100;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0x1:\n\t\t\t\t\t\t\tcapBuffer = 0x101;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst toCapitalize = capBuffer & 0x1;\n\t\t\t\tcapBuffer >>= 1;\n\t\t\t\tif (toCapitalize) {\n\t\t\t\t\tcurChar = String.fromCharCode(curCharCode - 32);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstr += curChar;\n\t\t} else {\n\t\t\tcapBuffer = 1;\n\t\t\t// pull out the next unsafe string\n\t\t\tlet isEmpty = true;\n\t\t\tdo {\n\t\t\t\tswitch (streamRead(unsafeStream, 2, 0x3)) {\n\t\t\t\tcase 0x0:\n\t\t\t\t\t// go back to parsing safe chars\n\t\t\t\t\tcurChar = '';\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x1:\n\t\t\t\t\tthrow new Error(\"Invalid capitalization token\");\n\t\t\t\tcase 0x2:\n\t\t\t\t\tcurChar = UNSAFE_MAP.charAt(streamRead(unsafeStream, 5, 0x1F));\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 0x3:\n\t\t\t\t\tif (streamRead(unsafeStream, 1, 0x1)) {\n\t\t\t\t\t\tcurChar = String.fromCharCode(streamRead(unsafeStream, 16, 0xFFFF));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurChar = ' ';\n\t\t\t\t\t}\n\t\t\t\t\tisEmpty = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tstr += curChar;\n\t\t\t} while (curChar);\n\t\t\tif (isEmpty && i !== lastDashIndex) str += ' ';\n\t\t}\n\t}\n\treturn str;\n}\n\nexport function vizStream(codeBuf: string, translate = true) {\n\tlet spacedStream = '';\n\tif (codeBuf.startsWith('0')) {\n\t\tcodeBuf = codeBuf.slice(1);\n\t\tspacedStream = ' [no safe chars]' + spacedStream;\n\t}\n\tif (codeBuf.endsWith('2')) {\n\t\tcodeBuf = codeBuf.slice(0, -1);\n\t\tspacedStream = ' [start unsafe]' + spacedStream;\n\t}\n\tconst stream: DashyStream = {\n\t\tcodeBuf,\n\t\tbuf: 0x0,\n\t\tbufLength: 0,\n\t};\n\n\tfunction vizBlock(s: DashyStream, bufLen: number) {\n\t\tconst buf = streamRead(s, bufLen);\n\t\treturn buf.toString(2).padStart(bufLen, '0');\n\t}\n\n\twhile (stream.bufLength > 0 || stream.codeBuf) {\n\t\tswitch (streamRead(stream, 2)) {\n\t\tcase 0x0:\n\t\t\tspacedStream = (translate ? ' |' : ' 00') + spacedStream;\n\t\t\tbreak;\n\t\tcase 0x1:\n\t\t\tif (streamRead(stream, 1)) {\n\t\t\t\tspacedStream = ' ' + vizBlock(stream, 8) + (translate ? '-cap' : '_1_01') + spacedStream;\n\t\t\t} else {\n\t\t\t\tspacedStream = (translate ? ' capfirst' : ' 0_01') + spacedStream;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x2:\n\t\t\tspacedStream = ' ' + vizBlock(stream, 5) + (translate ? '-ascii' : '_10') + spacedStream;\n\t\t\tbreak;\n\t\tcase 0x3:\n\t\t\tif (streamRead(stream, 1)) {\n\t\t\t\tspacedStream = ' ' + vizBlock(stream, 16) + (translate ? '-utf' : '_1_11') + spacedStream;\n\t\t\t} else {\n\t\t\t\tspacedStream = (translate ? ' space' : ' 0_11') + spacedStream;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn spacedStream;\n}\n"],
  "mappings": "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",
  "names": []
}
