{
  "version": 3,
  "sources": ["../../lib/fs.ts"],
  "sourcesContent": ["/**\n * FS\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * An abstraction layer around Node's filesystem.\n *\n * Advantages:\n * - write() etc do nothing in unit tests\n * - paths are always relative to PS's base directory\n * - Promises (seriously wtf Node Core what are you thinking)\n * - PS-style API: FS(\"foo.txt\").write(\"bar\") for easier argument order\n * - mkdirp\n *\n * FS is used nearly everywhere, but exceptions include:\n * - crashlogger.js - in case the crash is in here\n * - repl.js - which use Unix sockets out of this file's scope\n * - launch script - happens before modules are loaded\n * - sim/ - intended to be self-contained\n *\n * @author Guangcong Luo <guangcongluo@gmail.com>\n * @license MIT\n */\n\nimport * as fs from 'fs';\nimport * as pathModule from 'path';\nimport { ReadStream, WriteStream } from './streams';\n\n// not sure why it's necessary to use path.sep, but testing with Windows showed it was\nconst DIST = `${pathModule.sep}dist${pathModule.sep}`;\n// account for pwd/dist/lib\nconst ROOT_PATH = pathModule.resolve(__dirname, __dirname.includes(DIST) ? '..' : '', '..');\n\ninterface PendingUpdate {\n\tisWriting: boolean; // true: waiting on a call to FS.write, false: waiting on a throttle\n\tpendingDataFetcher: (() => string | Buffer) | null;\n\tpendingOptions: AnyObject | null;\n\tthrottleTime: number; // throttling until time (0 for no throttle)\n\tthrottleTimer: NodeJS.Timeout | null;\n}\n\ndeclare const __fsState: { pendingUpdates: Map<string, PendingUpdate> };\n// config needs to be declared here since we access it as global.Config?.nofswriting\n// (so we can use it without the global)\ndeclare const global: { __fsState: typeof __fsState, Config: any };\nif (!global.__fsState) {\n\tglobal.__fsState = {\n\t\tpendingUpdates: new Map(),\n\t};\n}\n\nexport class FSPath {\n\tpath: string;\n\n\tconstructor(path: string) {\n\t\tthis.path = pathModule.resolve(ROOT_PATH, path);\n\t}\n\n\tparentDir() {\n\t\treturn new FSPath(pathModule.dirname(this.path));\n\t}\n\n\tread(options: AnyObject | BufferEncoding = 'utf8'): Promise<string> {\n\t\tif (typeof options !== 'string' && options.encoding === undefined) {\n\t\t\toptions.encoding = 'utf8';\n\t\t}\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readFile(this.path, options, (err, data) => {\n\t\t\t\terr ? reject(err) : resolve(data as string);\n\t\t\t});\n\t\t});\n\t}\n\n\treadSync(options: AnyObject | string = 'utf8'): string {\n\t\tif (typeof options !== 'string' && options.encoding === undefined) {\n\t\t\toptions.encoding = 'utf8';\n\t\t}\n\t\treturn fs.readFileSync(this.path, options as { encoding: 'utf8' });\n\t}\n\n\treadBuffer(options: AnyObject | BufferEncoding = {}): Promise<Buffer> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readFile(this.path, options, (err, data) => {\n\t\t\t\terr ? reject(err) : resolve(data as Buffer);\n\t\t\t});\n\t\t});\n\t}\n\n\treadBufferSync(options: AnyObject | string = {}) {\n\t\treturn fs.readFileSync(this.path, options as { encoding: null });\n\t}\n\n\texists(): Promise<boolean> {\n\t\treturn new Promise(resolve => {\n\t\t\tfs.exists(this.path, exists => {\n\t\t\t\tresolve(exists);\n\t\t\t});\n\t\t});\n\t}\n\n\texistsSync() {\n\t\treturn fs.existsSync(this.path);\n\t}\n\n\treadIfExists(): Promise<string> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readFile(this.path, 'utf8', (err, data) => {\n\t\t\t\tif (err && err.code === 'ENOENT') return resolve('');\n\t\t\t\terr ? reject(err) : resolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\treadIfExistsSync() {\n\t\ttry {\n\t\t\treturn fs.readFileSync(this.path, 'utf8');\n\t\t} catch (err: any) {\n\t\t\tif (err.code !== 'ENOENT') throw err;\n\t\t}\n\t\treturn '';\n\t}\n\n\twrite(data: string | Buffer, options: AnyObject = {}) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.writeFile(this.path, data, options, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\twriteSync(data: string | Buffer, options: AnyObject = {}) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.writeFileSync(this.path, data, options);\n\t}\n\n\t/**\n\t * Writes to a new file before renaming to replace an old file. If\n\t * the process crashes while writing, the old file won't be lost.\n\t * Does not protect against simultaneous writing; use writeUpdate\n\t * for that.\n\t */\n\tasync safeWrite(data: string | Buffer, options: AnyObject = {}) {\n\t\tawait FS(this.path + '.NEW').write(data, options);\n\t\tawait FS(this.path + '.NEW').rename(this.path);\n\t}\n\n\tsafeWriteSync(data: string | Buffer, options: AnyObject = {}) {\n\t\tFS(this.path + '.NEW').writeSync(data, options);\n\t\tFS(this.path + '.NEW').renameSync(this.path);\n\t}\n\n\t/**\n\t * Safest way to update a file with in-memory state. Pass a callback\n\t * that fetches the data to be written. It will write an update,\n\t * avoiding race conditions. The callback may not necessarily be\n\t * called, if `writeUpdate` is called many times in a short period.\n\t *\n\t * `options.throttle`, if it exists, will make sure updates are not\n\t * written more than once every `options.throttle` milliseconds.\n\t *\n\t * No synchronous version because there's no risk of race conditions\n\t * with synchronous code; just use `safeWriteSync`.\n\t */\n\twriteUpdate(dataFetcher: () => string | Buffer, options: AnyObject = {}) {\n\t\tif (global.Config?.nofswriting) return;\n\t\tconst pendingUpdate: PendingUpdate | undefined = __fsState.pendingUpdates.get(this.path);\n\n\t\tconst throttleTime = options.throttle ? Date.now() + options.throttle : 0;\n\n\t\tif (pendingUpdate) {\n\t\t\tpendingUpdate.pendingDataFetcher = dataFetcher;\n\t\t\tpendingUpdate.pendingOptions = options;\n\t\t\tif (pendingUpdate.throttleTimer && throttleTime < pendingUpdate.throttleTime) {\n\t\t\t\tpendingUpdate.throttleTime = throttleTime;\n\t\t\t\tclearTimeout(pendingUpdate.throttleTimer);\n\t\t\t\tpendingUpdate.throttleTimer = setTimeout(() => this.checkNextUpdate(), throttleTime - Date.now());\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!throttleTime) {\n\t\t\tthis.writeUpdateNow(dataFetcher, options);\n\t\t\treturn;\n\t\t}\n\n\t\tconst update: PendingUpdate = {\n\t\t\tisWriting: false,\n\t\t\tpendingDataFetcher: dataFetcher,\n\t\t\tpendingOptions: options,\n\t\t\tthrottleTime,\n\t\t\tthrottleTimer: setTimeout(() => this.checkNextUpdate(), throttleTime - Date.now()),\n\t\t};\n\t\t__fsState.pendingUpdates.set(this.path, update);\n\t}\n\n\twriteUpdateNow(dataFetcher: () => string | Buffer, options: AnyObject) {\n\t\tconst throttleTime = options.throttle ? Date.now() + options.throttle : 0;\n\t\tconst update = {\n\t\t\tisWriting: true,\n\t\t\tpendingDataFetcher: null,\n\t\t\tpendingOptions: null,\n\t\t\tthrottleTime,\n\t\t\tthrottleTimer: null,\n\t\t};\n\t\t__fsState.pendingUpdates.set(this.path, update);\n\t\tvoid this.safeWrite(dataFetcher(), options).then(() => this.finishUpdate());\n\t}\n\tcheckNextUpdate() {\n\t\tconst pendingUpdate = __fsState.pendingUpdates.get(this.path);\n\t\tif (!pendingUpdate) throw new Error(`FS: Pending update not found`);\n\t\tif (pendingUpdate.isWriting) throw new Error(`FS: Conflicting update`);\n\n\t\tconst { pendingDataFetcher: dataFetcher, pendingOptions: options } = pendingUpdate;\n\t\tif (!dataFetcher || !options) {\n\t\t\t// no pending update\n\t\t\t__fsState.pendingUpdates.delete(this.path);\n\t\t\treturn;\n\t\t}\n\n\t\tthis.writeUpdateNow(dataFetcher, options);\n\t}\n\tfinishUpdate() {\n\t\tconst pendingUpdate = __fsState.pendingUpdates.get(this.path);\n\t\tif (!pendingUpdate) throw new Error(`FS: Pending update not found`);\n\t\tif (!pendingUpdate.isWriting) throw new Error(`FS: Conflicting update`);\n\n\t\tpendingUpdate.isWriting = false;\n\t\tconst throttleTime = pendingUpdate.throttleTime;\n\t\tif (!throttleTime || throttleTime < Date.now()) {\n\t\t\tthis.checkNextUpdate();\n\t\t\treturn;\n\t\t}\n\n\t\tpendingUpdate.throttleTimer = setTimeout(() => this.checkNextUpdate(), throttleTime - Date.now());\n\t}\n\n\tappend(data: string | Buffer, options: AnyObject = {}) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.appendFile(this.path, data, options, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tappendSync(data: string | Buffer, options: AnyObject = {}) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.appendFileSync(this.path, data, options);\n\t}\n\n\tsymlinkTo(target: string) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.symlink(target, this.path, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tsymlinkToSync(target: string) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.symlinkSync(target, this.path);\n\t}\n\n\tcopyFile(dest: string) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.copyFile(this.path, dest, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\trename(target: string) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.rename(this.path, target, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\trenameSync(target: string) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.renameSync(this.path, target);\n\t}\n\n\treaddir(): Promise<string[]> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tfs.readdir(this.path, (err, data) => {\n\t\t\t\terr ? reject(err) : resolve(data);\n\t\t\t});\n\t\t});\n\t}\n\n\treaddirSync() {\n\t\treturn fs.readdirSync(this.path);\n\t}\n\n\tasync readdirIfExists(): Promise<string[]> {\n\t\tif (await this.exists()) return this.readdir();\n\t\treturn Promise.resolve([]);\n\t}\n\n\treaddirIfExistsSync() {\n\t\tif (this.existsSync()) return this.readdirSync();\n\t\treturn [];\n\t}\n\n\tcreateReadStream() {\n\t\treturn new FileReadStream(this.path);\n\t}\n\n\tcreateWriteStream(options = {}): WriteStream {\n\t\tif (global.Config?.nofswriting) {\n\t\t\treturn new WriteStream({ write() {} });\n\t\t}\n\t\treturn new WriteStream(fs.createWriteStream(this.path, options));\n\t}\n\n\tcreateAppendStream(options: AnyObject = {}): WriteStream {\n\t\tif (global.Config?.nofswriting) {\n\t\t\treturn new WriteStream({ write() {} });\n\t\t}\n\t\toptions.flags = options.flags || 'a';\n\t\treturn new WriteStream(fs.createWriteStream(this.path, options));\n\t}\n\n\tunlinkIfExists() {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.unlink(this.path, err => {\n\t\t\t\tif (err && err.code === 'ENOENT') return resolve();\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tunlinkIfExistsSync() {\n\t\tif (global.Config?.nofswriting) return;\n\t\ttry {\n\t\t\tfs.unlinkSync(this.path);\n\t\t} catch (err: any) {\n\t\t\tif (err.code !== 'ENOENT') throw err;\n\t\t}\n\t}\n\n\tasync rmdir(recursive?: boolean) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.rmdir(this.path, { recursive }, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\trmdirSync(recursive?: boolean) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.rmdirSync(this.path, { recursive });\n\t}\n\n\tmkdir(mode: string | number = 0o755) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.mkdir(this.path, mode, err => {\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tmkdirSync(mode: string | number = 0o755) {\n\t\tif (global.Config?.nofswriting) return;\n\t\treturn fs.mkdirSync(this.path, mode);\n\t}\n\n\tmkdirIfNonexistent(mode: string | number = 0o755) {\n\t\tif (global.Config?.nofswriting) return Promise.resolve();\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tfs.mkdir(this.path, mode, err => {\n\t\t\t\tif (err && err.code === 'EEXIST') return resolve();\n\t\t\t\terr ? reject(err) : resolve();\n\t\t\t});\n\t\t});\n\t}\n\n\tmkdirIfNonexistentSync(mode: string | number = 0o755) {\n\t\tif (global.Config?.nofswriting) return;\n\t\ttry {\n\t\t\tfs.mkdirSync(this.path, mode);\n\t\t} catch (err: any) {\n\t\t\tif (err.code !== 'EEXIST') throw err;\n\t\t}\n\t}\n\n\t/**\n\t * Creates the directory (and any parent directories if necessary).\n\t * Does not throw if the directory already exists.\n\t */\n\tasync mkdirp(mode: string | number = 0o755) {\n\t\ttry {\n\t\t\tawait this.mkdirIfNonexistent(mode);\n\t\t} catch (err: any) {\n\t\t\tif (err.code !== 'ENOENT') throw err;\n\t\t\tawait this.parentDir().mkdirp(mode);\n\t\t\tawait this.mkdirIfNonexistent(mode);\n\t\t}\n\t}\n\n\t/**\n\t * Creates the directory (and any parent directories if necessary).\n\t * Does not throw if the directory already exists. Synchronous.\n\t */\n\tmkdirpSync(mode: string | number = 0o755) {\n\t\ttry {\n\t\t\tthis.mkdirIfNonexistentSync(mode);\n\t\t} catch (err: any) {\n\t\t\tif (err.code !== 'ENOENT') throw err;\n\t\t\tthis.parentDir().mkdirpSync(mode);\n\t\t\tthis.mkdirIfNonexistentSync(mode);\n\t\t}\n\t}\n\n\t/** Calls the callback if the file is modified. */\n\tonModify(callback: () => void) {\n\t\tfs.watchFile(this.path, (curr, prev) => {\n\t\t\tif (curr.mtime > prev.mtime) return callback();\n\t\t});\n\t}\n\n\t/** Clears callbacks added with onModify(). */\n\tunwatch() {\n\t\tfs.unwatchFile(this.path);\n\t}\n\n\tasync isFile() {\n\t\treturn new Promise<boolean>((resolve, reject) => {\n\t\t\tfs.stat(this.path, (err, stats) => {\n\t\t\t\terr ? reject(err) : resolve(stats.isFile());\n\t\t\t});\n\t\t});\n\t}\n\n\tisFileSync() {\n\t\treturn fs.statSync(this.path).isFile();\n\t}\n\n\tasync isDirectory() {\n\t\treturn new Promise<boolean>((resolve, reject) => {\n\t\t\tfs.stat(this.path, (err, stats) => {\n\t\t\t\terr ? reject(err) : resolve(stats.isDirectory());\n\t\t\t});\n\t\t});\n\t}\n\n\tisDirectorySync() {\n\t\treturn fs.statSync(this.path).isDirectory();\n\t}\n\n\tasync realpath() {\n\t\treturn new Promise<string>((resolve, reject) => {\n\t\t\tfs.realpath(this.path, (err, path) => {\n\t\t\t\terr ? reject(err) : resolve(path);\n\t\t\t});\n\t\t});\n\t}\n\n\trealpathSync() {\n\t\treturn fs.realpathSync(this.path);\n\t}\n}\n\nclass FileReadStream extends ReadStream {\n\tfd: Promise<number>;\n\n\tconstructor(file: string) {\n\t\tsuper();\n\t\tthis.fd = new Promise((resolve, reject) => {\n\t\t\tfs.open(file, 'r', (err, fd) => err ? reject(err) : resolve(fd));\n\t\t});\n\t\tthis.atEOF = false;\n\t}\n\n\toverride _read(size = 16384): Promise<void> {\n\t\treturn new Promise<void>((resolve, reject) => {\n\t\t\tif (this.atEOF) return void resolve();\n\t\t\tthis.ensureCapacity(size);\n\t\t\tvoid this.fd.then(fd => {\n\t\t\t\tfs.read(fd, this.buf, this.bufEnd, size, null, (err, bytesRead, buf) => {\n\t\t\t\t\tif (err) return reject(err);\n\t\t\t\t\tif (!bytesRead) {\n\t\t\t\t\t\tthis.atEOF = true;\n\t\t\t\t\t\tthis.resolvePush();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\t\t\t\t\tthis.bufEnd += bytesRead;\n\t\t\t\t\t// throw new Error([...this.buf].map(x => x.toString(16)).join(' '));\n\t\t\t\t\tthis.resolvePush();\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\toverride _destroy() {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tvoid this.fd.then(fd => {\n\t\t\t\tfs.close(fd, () => resolve());\n\t\t\t});\n\t\t});\n\t}\n}\n\nfunction getFs(path: string) {\n\treturn new FSPath(path);\n}\n\nexport const FS = Object.assign(getFs, {\n\tFileReadStream, FSPath, ROOT_PATH,\n});\n"],
  "mappings": "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",
  "names": []
}
