{
  "version": 3,
  "sources": ["../../server/users.ts"],
  "sourcesContent": ["/**\n * Users\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * Most of the communication with users happens here.\n *\n * There are two object types this file introduces:\n * User and Connection.\n *\n * A User object is a user, identified by username. A guest has a\n * username in the form \"Guest 12\". Any user whose username starts\n * with \"Guest\" must be a guest; normal users are not allowed to\n * use usernames starting with \"Guest\".\n *\n * A User can be connected to Pokemon Showdown from any number of tabs\n * or computers at the same time. Each connection is represented by\n * a Connection object. A user tracks its connections in\n * user.connections - if this array is empty, the user is offline.\n *\n * `Users.users` is the global table of all users, a `Map` of `ID:User`.\n * Users should normally be accessed with `Users.get(userid)`\n *\n * `Users.connections` is the global table of all connections, a `Map` of\n * `string:Connection` (the string is mostly meaningless but see\n * `connection.id` for details). Connections are normally accessed through\n * `user.connections`.\n *\n * @license MIT\n */\n\ntype StatusType = 'online' | 'busy' | 'idle';\n\nconst THROTTLE_DELAY = 600;\nconst THROTTLE_DELAY_TRUSTED = 100;\nconst THROTTLE_DELAY_PUBLIC_BOT = 25;\nconst THROTTLE_BUFFER_LIMIT = 6;\nconst THROTTLE_MULTILINE_WARN = 3;\nconst THROTTLE_MULTILINE_WARN_STAFF = 6;\nconst THROTTLE_MULTILINE_WARN_ADMIN = 25;\n\nconst NAMECHANGE_THROTTLE = 2 * 60 * 1000; // 2 minutes\nconst NAMES_PER_THROTTLE = 3;\n\nconst PERMALOCK_CACHE_TIME = 30 * 24 * 60 * 60 * 1000; // 30 days\n\nconst DEFAULT_TRAINER_SPRITES = [1, 2, 101, 102, 169, 170, 265, 266];\n\nimport { Utils, type ProcessManager } from '../lib';\nimport {\n\tAuth, GlobalAuth, PLAYER_SYMBOL, HOST_SYMBOL, type RoomPermission, type GlobalPermission,\n} from './user-groups';\n\nconst MINUTES = 60 * 1000;\nconst IDLE_TIMER = 60 * MINUTES;\nconst STAFF_IDLE_TIMER = 30 * MINUTES;\nconst CONNECTION_EXPIRY_TIME = 24 * 60 * MINUTES;\n\n/*********************************************************\n * Utility functions\n *********************************************************/\n\n// Low-level functions for manipulating Users.users and Users.prevUsers\n// Keeping them all here makes it easy to ensure they stay consistent\n\nfunction move(user: User, newUserid: ID) {\n\tif (user.id === newUserid) return true;\n\tif (!user) return false;\n\n\t// doing it this way mathematically ensures no cycles\n\tprevUsers.delete(newUserid);\n\tprevUsers.set(user.id, newUserid);\n\n\tusers.delete(user.id);\n\tuser.id = newUserid;\n\tusers.set(newUserid, user);\n\n\treturn true;\n}\nfunction add(user: User) {\n\tif (user.id) throw new Error(`Adding a user that already exists`);\n\n\tnumUsers++;\n\tuser.guestNum = numUsers;\n\tuser.name = `Guest ${numUsers}`;\n\tuser.id = toID(user.name);\n\n\tif (users.has(user.id)) throw new Error(`userid taken: ${user.id}`);\n\tusers.set(user.id, user);\n}\nfunction deleteUser(user: User) {\n\tprevUsers.delete(`guest${user.guestNum}` as ID);\n\tusers.delete(user.id);\n}\nfunction merge(toRemain: User, toDestroy: User) {\n\tprevUsers.delete(toRemain.id);\n\tprevUsers.set(toDestroy.id, toRemain.id);\n}\n\n/**\n * Get a user.\n *\n * Usage:\n *   Users.get(userid or username)\n *\n * Returns the corresponding User object, or null if no matching\n * was found.\n *\n * By default, this function will track users across name changes.\n * For instance, if \"Some dude\" changed their name to \"Some guy\",\n * Users.get(\"Some dude\") will give you \"Some guy\"s user object.\n *\n * If this behavior is undesirable, use Users.getExact.\n */\nfunction getUser(name: string | User | null, exactName = false) {\n\tif (!name || name === '!') return null;\n\tif ((name as User).id) return name as User;\n\tlet userid = toID(name);\n\tlet i = 0;\n\tif (!exactName) {\n\t\twhile (userid && !users.has(userid) && i < 1000) {\n\t\t\tuserid = prevUsers.get(userid)!;\n\t\t\ti++;\n\t\t}\n\t}\n\treturn users.get(userid) || null;\n}\n\n/**\n * Get a user by their exact username.\n *\n * Usage:\n *   Users.getExact(userid or username)\n *\n * Like Users.get, but won't track across username changes.\n *\n * Users.get(userid or username, true) is equivalent to\n * Users.getExact(userid or username).\n * The former is not recommended because it's less readable.\n */\nfunction getExactUser(name: string | User) {\n\treturn getUser(name, true);\n}\n\n/**\n * Get a list of all users matching a list of userids and ips.\n *\n * Usage:\n *   Users.findUsers([userids], [ips])\n */\nfunction findUsers(userids: ID[], ips: string[], options: { forPunishment?: boolean, includeTrusted?: boolean } = {}) {\n\tconst matches: User[] = [];\n\tif (options.forPunishment) ips = ips.filter(ip => !Punishments.isSharedIp(ip));\n\tconst ipMatcher = IPTools.checker(ips);\n\tfor (const user of users.values()) {\n\t\tif (!options.forPunishment && !user.named && !user.connected) continue;\n\t\tif (!options.includeTrusted && user.trusted) continue;\n\t\tif (userids.includes(user.id)) {\n\t\t\tmatches.push(user);\n\t\t\tcontinue;\n\t\t}\n\t\tif (user.ips.some(ipMatcher)) {\n\t\t\tmatches.push(user);\n\t\t}\n\t}\n\treturn matches;\n}\n\n/*********************************************************\n * User groups\n*********************************************************/\nconst globalAuth = new GlobalAuth();\n\nfunction isUsernameKnown(name: string) {\n\tconst userid = toID(name);\n\tif (Users.get(userid)) return true;\n\tif (globalAuth.has(userid)) return true;\n\tfor (const room of Rooms.global.chatRooms) {\n\t\tif (room.auth.has(userid)) return true;\n\t}\n\treturn false;\n}\n\nfunction isUsername(name: string) {\n\treturn /[A-Za-z0-9]/.test(name.charAt(0)) && /[A-Za-z]/.test(name) && !name.includes(',');\n}\n\nfunction isTrusted(userid: ID) {\n\tif (globalAuth.has(userid)) return userid;\n\tfor (const room of Rooms.global.chatRooms) {\n\t\tif (room.persist && !room.settings.isPrivate && room.auth.isStaff(userid)) {\n\t\t\treturn userid;\n\t\t}\n\t}\n\tconst staffRoom = Rooms.get('staff');\n\tconst staffAuth = staffRoom && !!(staffRoom.auth.has(userid) || staffRoom.users[userid]);\n\treturn staffAuth ? userid : false;\n}\n\nfunction isPublicBot(userid: ID) {\n\tif (globalAuth.get(userid) === '*') return true;\n\tfor (const room of Rooms.global.chatRooms) {\n\t\tif (room.persist && !room.settings.isPrivate && room.auth.get(userid) === '*') {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/*********************************************************\n * User and Connection classes\n *********************************************************/\n\nconst connections = new Map<string, Connection>();\n\nexport class Connection {\n\t/**\n\t * Connection IDs are mostly meaningless, beyond being known to be\n\t * unique among connections. They set in `socketConnect` to\n\t * `workerid-socketid`, so for instance `2-523` would be the 523th\n\t * connection to the 2nd socket worker process.\n\t */\n\treadonly id: string;\n\treadonly socketid: string;\n\treadonly worker: ProcessManager.StreamWorker;\n\treadonly inRooms: Set<RoomID>;\n\treadonly ip: string;\n\treadonly protocol: string;\n\treadonly connectedAt: number;\n\t/**\n\t * This can be null during initialization and after disconnecting,\n\t * but we're asserting it non-null for ease of use. The main risk\n\t * is async code, where you need to re-check that it's not null\n\t * before using it.\n\t */\n\tuser: User;\n\tchallenge: string;\n\tautojoins: string;\n\t/** The last bot html page this connection requested, formatted as `${bot.id}-${pageid}` */\n\tlastRequestedPage: string | null;\n\tlastActiveTime: number;\n\topenPages: null | Set<string>;\n\t/**\n\t * Used to distinguish Connection from User.\n\t *\n\t * Makes it easy to do something like\n\t * `for (const conn of (userOrConn.connections || [userOrConn]))`\n\t */\n\treadonly connections = null;\n\tconstructor(\n\t\tid: string,\n\t\tworker: ProcessManager.StreamWorker,\n\t\tsocketid: string,\n\t\tuser: User | null,\n\t\tip: string | null,\n\t\tprotocol: string | null\n\t) {\n\t\tconst now = Date.now();\n\n\t\tthis.id = id;\n\t\tthis.socketid = socketid;\n\t\tthis.worker = worker;\n\t\tthis.inRooms = new Set();\n\n\t\tthis.ip = ip || '';\n\t\tthis.protocol = protocol || '';\n\n\t\tthis.connectedAt = now;\n\n\t\tthis.user = user!;\n\n\t\tthis.challenge = '';\n\t\tthis.autojoins = '';\n\t\tthis.lastRequestedPage = null;\n\t\tthis.lastActiveTime = now;\n\t\tthis.openPages = null;\n\t}\n\tsendTo(roomid: RoomID | BasicRoom | null, data: string) {\n\t\tif (roomid && typeof roomid !== 'string') roomid = roomid.roomid;\n\t\tif (roomid && roomid !== 'lobby') data = `>${roomid}\\n${data}`;\n\t\tSockets.socketSend(this.worker, this.socketid, data);\n\t\tMonitor.countNetworkUse(data.length);\n\t}\n\n\tsend(data: string) {\n\t\tSockets.socketSend(this.worker, this.socketid, data);\n\t\tMonitor.countNetworkUse(data.length);\n\t}\n\n\tdestroy() {\n\t\tSockets.socketDisconnect(this.worker, this.socketid);\n\t\tthis.onDisconnect();\n\t}\n\tonDisconnect() {\n\t\tconnections.delete(this.id);\n\t\tif (this.user) this.user.onDisconnect(this);\n\t\tthis.user = null!;\n\t}\n\n\tpopup(message: string) {\n\t\tthis.send(`|popup|` + message.replace(/\\n/g, '||'));\n\t}\n\n\tjoinRoom(room: Room) {\n\t\tif (this.inRooms.has(room.roomid)) return;\n\t\tthis.inRooms.add(room.roomid);\n\t\tSockets.roomAdd(this.worker, room.roomid, this.socketid);\n\t}\n\tleaveRoom(room: Room) {\n\t\tif (this.inRooms.has(room.roomid)) {\n\t\t\tthis.inRooms.delete(room.roomid);\n\t\t\tSockets.roomRemove(this.worker, room.roomid, this.socketid);\n\t\t}\n\t}\n\ttoString() {\n\t\tlet buf = this.user ? `${this.user.id}[${this.user.connections.indexOf(this)}]` : `[disconnected]`;\n\t\tbuf += `:${this.ip}`;\n\t\tif (this.protocol !== 'websocket') buf += `:${this.protocol}`;\n\t\treturn buf;\n\t}\n}\n\ntype ChatQueueEntry = [string, RoomID, Connection];\n\nexport interface UserSettings {\n\tblockChallenges: boolean | AuthLevel | 'friends';\n\tblockPMs: boolean | AuthLevel | 'friends';\n\tignoreTickets: boolean;\n\thideBattlesFromTrainerCard: boolean;\n\tblockInvites: AuthLevel | boolean;\n\tdoNotDisturb: boolean;\n\tblockFriendRequests: boolean;\n\tallowFriendNotifications: boolean;\n\tdisplayBattlesToFriends: boolean;\n\thideLogins: boolean;\n}\n\n// User\nexport class User extends Chat.MessageContext {\n\t/** In addition to needing it to implement MessageContext, this is also nice for compatibility with Connection. */\n\toverride readonly user: User;\n\t/**\n\t * Not a source of truth - should always be in sync with\n\t * `[...Rooms.rooms.values()].filter(room => this.id in room.users)`\n\t */\n\treadonly inRooms: Set<RoomID>;\n\t/**\n\t * Not a source of truth - should always in sync with\n\t * `[...Rooms.rooms.values()].filter(`\n\t * `  room => room.game && this.id in room.game.playerTable && !room.game.ended`\n\t * `)`\n\t */\n\treadonly games: Set<RoomID>;\n\tmmrCache: { [format: string]: number };\n\tguestNum: number;\n\tname: string;\n\tnamed: boolean;\n\tregistered: boolean;\n\tid: ID;\n\ttempGroup: GroupSymbol;\n\tavatar: string | number;\n\toverride language: ID | null;\n\n\tconnected: boolean;\n\tconnections: Connection[];\n\tlatestHost: string;\n\tlatestHostType: string;\n\tips: string[];\n\tlatestIp: string;\n\tlocked: ID | PunishType | null;\n\tsemilocked: ID | PunishType | null;\n\tnamelocked: ID | PunishType | null;\n\tpermalocked: ID | PunishType | null;\n\tpunishmentTimer: NodeJS.Timeout | null;\n\tpreviousIDs: ID[];\n\n\tlastChallenge: number;\n\tlastPM: string;\n\tlastMatch: ID;\n\n\tsettings: UserSettings;\n\n\tbattleSettings: {\n\t\tteam: string,\n\t\thidden: boolean,\n\t\tinviteOnly: boolean,\n\t\tspecial?: string,\n\t};\n\n\tisSysop: boolean;\n\tisStaff: boolean;\n\tisPublicBot: boolean;\n\tlastDisconnected: number;\n\tlastConnected: number;\n\tfoodfight?: { generatedTeam: string[], dish: string, ingredients: string[], timestamp: number };\n\tfriends?: Set<string>;\n\n\tchatQueue: ChatQueueEntry[] | null;\n\tchatQueueTimeout: NodeJS.Timeout | null;\n\tlastChatMessage: number;\n\tlastCommand: string;\n\n\tnotified: {\n\t\tblockChallenges: boolean,\n\t\tblockPMs: boolean,\n\t\tblockInvites: boolean,\n\t\tpunishment: boolean,\n\t\tlock: boolean,\n\t};\n\n\tlastMessage: string;\n\tlastMessageTime: number;\n\tlastReportTime: number;\n\tlastNewNameTime = 0;\n\tnewNames = 0;\n\ts1: string;\n\ts2: string;\n\ts3: string;\n\n\tautoconfirmed: ID;\n\ttrusted: ID;\n\ttrackRename: string;\n\tstatusType: StatusType;\n\tuserMessage: string;\n\tlastWarnedAt: number;\n\tconstructor(connection: Connection) {\n\t\tsuper(connection.user);\n\t\tthis.user = this;\n\t\tthis.inRooms = new Set();\n\t\tthis.games = new Set();\n\t\tthis.mmrCache = Object.create(null);\n\t\tthis.guestNum = -1;\n\t\tthis.name = \"\";\n\t\tthis.named = false;\n\t\tthis.registered = false;\n\t\tthis.id = '';\n\t\tthis.tempGroup = Auth.defaultSymbol();\n\t\tthis.language = null;\n\n\t\tthis.avatar = DEFAULT_TRAINER_SPRITES[Math.floor(Math.random() * DEFAULT_TRAINER_SPRITES.length)];\n\n\t\tthis.connected = true;\n\t\tUsers.onlineCount++;\n\n\t\tif (connection.user) connection.user = this;\n\t\tthis.connections = [connection];\n\t\tthis.latestHost = '';\n\t\tthis.latestHostType = '';\n\t\tthis.ips = [connection.ip];\n\t\t// Note: Using the user's latest IP for anything will usually be\n\t\t//       wrong. Most code should use all of the IPs contained in\n\t\t//       the `ips` array, not just the latest IP.\n\t\tthis.latestIp = connection.ip;\n\t\tthis.locked = null;\n\t\tthis.semilocked = null;\n\t\tthis.namelocked = null;\n\t\tthis.permalocked = null;\n\t\tthis.punishmentTimer = null;\n\t\tthis.previousIDs = [];\n\n\t\t// misc state\n\t\tthis.lastChallenge = 0;\n\t\tthis.lastPM = '';\n\t\tthis.lastMatch = '';\n\n\t\t// settings\n\t\tthis.settings = {\n\t\t\tblockChallenges: false,\n\t\t\tblockPMs: false,\n\t\t\tignoreTickets: false,\n\t\t\thideBattlesFromTrainerCard: false,\n\t\t\tblockInvites: false,\n\t\t\tdoNotDisturb: false,\n\t\t\tblockFriendRequests: false,\n\t\t\tallowFriendNotifications: false,\n\t\t\tdisplayBattlesToFriends: false,\n\t\t\thideLogins: false,\n\t\t};\n\t\tthis.battleSettings = {\n\t\t\tteam: '',\n\t\t\thidden: false,\n\t\t\tinviteOnly: false,\n\t\t};\n\n\t\tthis.isSysop = false;\n\t\tthis.isStaff = false;\n\t\tthis.isPublicBot = false;\n\t\tthis.lastDisconnected = 0;\n\t\tthis.lastConnected = connection.connectedAt;\n\n\t\t// chat queue\n\t\tthis.chatQueue = null;\n\t\tthis.chatQueueTimeout = null;\n\t\tthis.lastChatMessage = 0;\n\t\tthis.lastCommand = '';\n\n\t\t// for the anti-spamming mechanism\n\t\tthis.lastMessage = ``;\n\t\tthis.lastMessageTime = 0;\n\t\tthis.lastReportTime = 0;\n\t\tthis.s1 = '';\n\t\tthis.s2 = '';\n\t\tthis.s3 = '';\n\n\t\tthis.notified = {\n\t\t\tblockChallenges: false,\n\t\t\tblockPMs: false,\n\t\t\tblockInvites: false,\n\t\t\tpunishment: false,\n\t\t\tlock: false,\n\t\t};\n\n\t\tthis.autoconfirmed = '';\n\t\tthis.trusted = '';\n\t\t// Used in punishments\n\t\tthis.trackRename = '';\n\t\tthis.statusType = 'online';\n\t\tthis.userMessage = '';\n\t\tthis.lastWarnedAt = 0;\n\n\t\t// initialize\n\t\tUsers.add(this);\n\t}\n\n\tsendTo(roomid: RoomID | BasicRoom | null, data: string) {\n\t\tif (roomid && typeof roomid !== 'string') roomid = roomid.roomid;\n\t\tif (roomid && roomid !== 'lobby') data = `>${roomid}\\n${data}`;\n\t\tfor (const connection of this.connections) {\n\t\t\tif (roomid && !connection.inRooms.has(roomid)) continue;\n\t\t\tconnection.send(data);\n\t\t\tMonitor.countNetworkUse(data.length);\n\t\t}\n\t}\n\tsend(data: string) {\n\t\tfor (const connection of this.connections) {\n\t\t\tconnection.send(data);\n\t\t\tMonitor.countNetworkUse(data.length);\n\t\t}\n\t}\n\tpopup(message: string) {\n\t\tthis.send(`|popup|` + message.replace(/\\n/g, '||'));\n\t}\n\tgetIdentity(room: BasicRoom | null = null) {\n\t\tconst punishgroups = Config.punishgroups || { locked: null, muted: null };\n\t\tif (this.locked || this.namelocked) {\n\t\t\tconst lockedSymbol = (punishgroups.locked?.symbol || '\\u203d');\n\t\t\treturn lockedSymbol + this.name;\n\t\t}\n\t\tif (room) {\n\t\t\tif (room.isMuted(this)) {\n\t\t\t\tconst mutedSymbol = (punishgroups.muted?.symbol || '!');\n\t\t\t\treturn mutedSymbol + this.name;\n\t\t\t}\n\t\t\treturn room.auth.get(this) + this.name;\n\t\t}\n\t\tif (this.semilocked) {\n\t\t\tconst mutedSymbol = (punishgroups.muted?.symbol || '!');\n\t\t\treturn mutedSymbol + this.name;\n\t\t}\n\t\treturn this.tempGroup + this.name;\n\t}\n\tgetIdentityWithStatus(room: BasicRoom | null = null) {\n\t\tconst identity = this.getIdentity(room);\n\t\tconst status = this.statusType === 'online' ? '' : '@!';\n\t\treturn `${identity}${status}`;\n\t}\n\tgetStatus() {\n\t\tconst statusMessage = this.statusType === 'busy' ? '!(Busy) ' : this.statusType === 'idle' ? '!(Idle) ' : '';\n\t\tconst status = statusMessage + (this.userMessage || '');\n\t\treturn status;\n\t}\n\tcan(permission: RoomPermission, target: User | null, room: BasicRoom, cmd?: string, cmdToken?: string): boolean;\n\tcan(permission: GlobalPermission, target?: User | null): boolean;\n\tcan(\n\t\tpermission: RoomPermission & GlobalPermission,\n\t\ttarget: User | null,\n\t\troom?: BasicRoom | null,\n\t\tcmd?: string,\n\t\tcmdToken?: string,\n\t): boolean;\n\tcan(\n\t\tpermission: string,\n\t\ttarget: User | null = null,\n\t\troom: BasicRoom | null = null,\n\t\tcmd?: string,\n\t\tcmdToken?: string,\n\t): boolean {\n\t\treturn Auth.hasPermission(this, permission, target, room, cmd, cmdToken);\n\t}\n\t/**\n\t * Special permission check for system operators\n\t */\n\thasSysopAccess() {\n\t\tif (this.isSysop && Config.backdoor) {\n\t\t\t// This is the Pokemon Showdown system operator backdoor.\n\n\t\t\t// Its main purpose is for situations where someone calls for help, and\n\t\t\t// your server has no admins online, or its admins have lost their\n\t\t\t// access through either a mistake or a bug - a system operator such as\n\t\t\t// Zarel will be able to fix it.\n\n\t\t\t// This relies on trusting Pokemon Showdown. If you do not trust\n\t\t\t// Pokemon Showdown, feel free to disable it, but remember that if\n\t\t\t// you mess up your server in whatever way, our tech support will not\n\t\t\t// be able to help you.\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t/**\n\t * Permission check for using the dev console\n\t *\n\t * The `console` permission is incredibly powerful because it allows the\n\t * execution of abitrary shell commands on the local computer As such, it\n\t * can only be used from a specified whitelist of IPs and userids. A\n\t * special permission check function is required to carry out this check\n\t * because we need to know which socket the client is connected from in\n\t * order to determine the relevant IP for checking the whitelist.\n\t */\n\thasConsoleAccess(connection: Connection) {\n\t\tif (this.hasSysopAccess()) return true;\n\t\tif (!this.can('console')) return false; // normal permission check\n\n\t\tconst whitelist = Config.consoleips || ['127.0.0.1'];\n\t\t// on the IP whitelist OR the userid whitelist\n\t\treturn whitelist.includes(connection.ip) || whitelist.includes(this.id);\n\t}\n\tresetName(isForceRenamed = false) {\n\t\treturn this.forceRename(`Guest ${this.guestNum}`, false, isForceRenamed);\n\t}\n\tupdateIdentity(roomid: RoomID | null = null) {\n\t\tif (roomid) {\n\t\t\treturn Rooms.get(roomid)!.onUpdateIdentity(this);\n\t\t}\n\t\tfor (const inRoomID of this.inRooms) {\n\t\t\tRooms.get(inRoomID)!.onUpdateIdentity(this);\n\t\t}\n\t}\n\tasync validateToken(token: string, name: string, userid: ID, connection: Connection) {\n\t\tif (!token && Config.noguestsecurity) {\n\t\t\tif (Users.isTrusted(userid)) {\n\t\t\t\tthis.send(`|nametaken|${name}|You need an authentication token to log in as a trusted user.`);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\treturn '1';\n\t\t}\n\n\t\tif (!token || token.startsWith(';')) {\n\t\t\tthis.send(`|nametaken|${name}|Your authentication token was invalid.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tlet challenge = '';\n\t\tif (connection) {\n\t\t\tchallenge = connection.challenge;\n\t\t}\n\t\tif (!challenge) {\n\t\t\tMonitor.warn(`verification failed; no challenge`);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst [tokenData, tokenSig] = Utils.splitFirst(token, ';');\n\t\tconst tokenDataSplit = tokenData.split(',');\n\t\tconst [signedChallenge, signedUserid, userType, signedDate, signedHostname] = tokenDataSplit;\n\n\t\tif (signedHostname && Config.legalhosts && !Config.legalhosts.includes(signedHostname)) {\n\t\t\tMonitor.warn(`forged assertion: ${tokenData}`);\n\t\t\tthis.send(`|nametaken|${name}|Your assertion is for the wrong server. This server is ${Config.legalhosts[0]}.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (tokenDataSplit.length < 5) {\n\t\t\tMonitor.warn(`outdated assertion format: ${tokenData}`);\n\t\t\tthis.send(`|nametaken|${name}|The assertion you sent us is corrupt or incorrect. Please send the exact assertion given by the login server's JSON response.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (signedUserid !== userid) {\n\t\t\t// userid mismatch\n\t\t\tthis.send(`|nametaken|${name}|Your verification signature doesn't match your new username.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tif (signedChallenge !== challenge) {\n\t\t\t// a user sent an invalid token\n\t\t\tMonitor.debug(`verify token challenge mismatch: ${signedChallenge} <=> ${challenge}`);\n\t\t\tthis.send(`|nametaken|${name}|Your verification signature doesn't match your authentication token.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst expiry = Config.tokenexpiry || 25 * 60 * 60;\n\t\tif (Math.abs(parseInt(signedDate) - Date.now() / 1000) > expiry) {\n\t\t\tMonitor.warn(`stale assertion: ${tokenData}`);\n\t\t\tthis.send(`|nametaken|${name}|Your assertion is stale. This usually means that the clock on the server computer is incorrect. If this is your server, please set the clock to the correct time.`);\n\t\t\treturn null;\n\t\t}\n\n\t\tconst success = await Verifier.verify(tokenData, tokenSig);\n\t\tif (!success) {\n\t\t\tMonitor.warn(`verify failed: ${token}`);\n\t\t\tMonitor.warn(`challenge was: ${challenge}`);\n\t\t\tthis.send(`|nametaken|${name}|Your verification signature was invalid.`);\n\t\t\treturn null;\n\t\t}\n\n\t\t// future-proofing\n\t\tthis.s1 = tokenDataSplit[5];\n\t\tthis.s2 = tokenDataSplit[6];\n\t\tthis.s3 = tokenDataSplit[7];\n\n\t\treturn userType;\n\t}\n\t/**\n\t * Do a rename, passing and validating a login token.\n\t *\n\t * @param name The name you want\n\t * @param token Signed assertion returned from login server\n\t * @param newlyRegistered Make sure this account will identify as registered\n\t * @param connection The connection asking for the rename\n\t */\n\tasync rename(name: string, token: string, newlyRegistered: boolean, connection: Connection) {\n\t\tlet userid = toID(name);\n\t\tif (userid !== this.id) {\n\t\t\tfor (const roomid of this.games) {\n\t\t\t\tconst room = Rooms.get(roomid);\n\t\t\t\tif (!room?.game || room.game.ended) {\n\t\t\t\t\tthis.games.delete(roomid);\n\t\t\t\t\tconsole.log(`desynced roomgame ${roomid} renaming ${this.id} -> ${userid}`);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (room.game.allowRenames || !this.named) continue;\n\t\t\t\tthis.popup(`You can't change your name right now because you're in ${room.game.title}, which doesn't allow renaming.`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tif (!name) name = '';\n\t\tif (!/[a-zA-Z]/.test(name)) {\n\t\t\t// technically it's not \"taken\", but if your client doesn't warn you\n\t\t\t// before it gets to this stage it's your own fault for getting a\n\t\t\t// bad error message\n\t\t\tthis.send(`|nametaken||Your name must contain at least one letter.`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (userid.length > 18) {\n\t\t\tthis.send(`|nametaken||Your name must be 18 characters or shorter.`);\n\t\t\treturn false;\n\t\t}\n\t\tname = Chat.namefilter(name, this);\n\t\tif (userid !== toID(name)) {\n\t\t\tif (name) {\n\t\t\t\tname = userid;\n\t\t\t} else {\n\t\t\t\tuserid = '';\n\t\t\t}\n\t\t}\n\t\tif (this.registered) newlyRegistered = false;\n\n\t\tif (!userid) {\n\t\t\tthis.send(`|nametaken||Your name contains a banned word.`);\n\t\t\treturn false;\n\t\t} else {\n\t\t\tif (userid === this.id && !newlyRegistered) {\n\t\t\t\treturn this.forceRename(name, this.registered);\n\t\t\t}\n\t\t}\n\n\t\tconst userType = await this.validateToken(token, name, userid, connection);\n\t\tif (userType === null) return;\n\t\tif (userType === '1') newlyRegistered = false;\n\n\t\tif (!this.trusted && userType === '1') { // userType '1' means unregistered\n\t\t\tconst elapsed = Date.now() - this.lastNewNameTime;\n\t\t\tif (elapsed < NAMECHANGE_THROTTLE && !Config.nothrottle) {\n\t\t\t\tif (this.newNames >= NAMES_PER_THROTTLE) {\n\t\t\t\t\tthis.send(\n\t\t\t\t\t\t`|nametaken|${name}|You must wait ${Chat.toDurationString(NAMECHANGE_THROTTLE - elapsed)} more\n\t\t\t\t\t\tseconds before using another unregistered name.`\n\t\t\t\t\t);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tthis.newNames++;\n\t\t\t} else {\n\t\t\t\tthis.lastNewNameTime = Date.now();\n\t\t\t\tthis.newNames = 1;\n\t\t\t}\n\t\t}\n\n\t\tthis.handleRename(name, userid, newlyRegistered, userType);\n\t\tvoid Punishments.checkIp(this, connection); // namelock enforcement and the like after merge\n\t}\n\n\thandleRename(name: string, userid: ID, newlyRegistered: boolean, userType: string) {\n\t\tconst registered = (userType !== '1');\n\n\t\tconst conflictUser = users.get(userid);\n\t\tif (conflictUser) {\n\t\t\t// unregistered users can only merge in limited situations\n\t\t\tlet canMerge = registered && conflictUser.registered;\n\t\t\tif (\n\t\t\t\t!registered && !conflictUser.registered && conflictUser.latestIp === this.latestIp &&\n\t\t\t\t!conflictUser.connected\n\t\t\t) {\n\t\t\t\tcanMerge = true;\n\t\t\t}\n\t\t\tif (!canMerge) {\n\t\t\t\tif (registered && !conflictUser.registered) {\n\t\t\t\t\t// user has just registered; don't merge just to be safe\n\t\t\t\t\tif (conflictUser !== this) conflictUser.resetName();\n\t\t\t\t} else {\n\t\t\t\t\tthis.send(`|nametaken|${name}|Someone is already using the name \"${conflictUser.name}\".`);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// user types:\n\t\t//   1: unregistered user\n\t\t//   2: registered user\n\t\t//   3: Pokemon Showdown system operator\n\t\t//   4: autoconfirmed\n\t\t//   5: permalocked\n\t\t//   6: permabanned\n\t\tif (registered) {\n\t\t\tif (userType === '3') {\n\t\t\t\tthis.isSysop = true;\n\t\t\t\tthis.isStaff = true;\n\t\t\t\tthis.trusted = userid;\n\t\t\t\tthis.autoconfirmed = userid;\n\t\t\t} else if (userType === '4') {\n\t\t\t\tthis.autoconfirmed = userid;\n\t\t\t} else if (userType === '5') {\n\t\t\t\tthis.permalocked = userid;\n\t\t\t\tvoid Punishments.lock(this, Date.now() + PERMALOCK_CACHE_TIME, userid, true, `Permalocked as ${name}`, true);\n\t\t\t} else if (userType === '6') {\n\t\t\t\tvoid Punishments.lock(this, Date.now() + PERMALOCK_CACHE_TIME, userid, true, `Permabanned as ${name}`, true);\n\t\t\t\tthis.disconnectAll();\n\t\t\t}\n\t\t}\n\t\tif (Users.isTrusted(userid)) {\n\t\t\tthis.trusted = userid;\n\t\t\tthis.autoconfirmed = userid;\n\t\t}\n\t\tif (this.trusted) {\n\t\t\tthis.locked = null;\n\t\t\tthis.namelocked = null;\n\t\t\tthis.permalocked = null;\n\t\t\tthis.semilocked = null;\n\t\t\tthis.destroyPunishmentTimer();\n\t\t}\n\n\t\tthis.isPublicBot = Users.isPublicBot(userid);\n\n\t\tChat.runHandlers('onRename', this, this.id, userid);\n\t\tlet user = users.get(userid);\n\t\tconst possibleUser = Users.get(userid);\n\t\tif (possibleUser?.namelocked) {\n\t\t\t// allows namelocked users to be merged\n\t\t\tuser = possibleUser;\n\t\t}\n\t\tif (user && user !== this) {\n\t\t\t// This user already exists; let's merge\n\t\t\tuser.merge(this);\n\n\t\t\tUsers.merge(user, this);\n\t\t\tfor (const id of this.previousIDs) {\n\t\t\t\tif (!user.previousIDs.includes(id)) user.previousIDs.push(id);\n\t\t\t}\n\t\t\tif (this.named && !user.previousIDs.includes(this.id)) user.previousIDs.push(this.id);\n\t\t\tthis.destroy();\n\n\t\t\tPunishments.checkName(user, userid, registered);\n\n\t\t\tRooms.global.checkAutojoin(user);\n\t\t\tRooms.global.rejoinGames(user);\n\t\t\tChat.loginfilter(user, this, userType);\n\t\t\treturn true;\n\t\t}\n\n\t\tPunishments.checkName(this, userid, registered);\n\t\tif (this.namelocked) {\n\t\t\tChat.loginfilter(this, null, userType);\n\t\t\treturn false;\n\t\t}\n\n\t\t// rename success\n\t\tif (!this.forceRename(name, registered)) {\n\t\t\treturn false;\n\t\t}\n\t\tRooms.global.checkAutojoin(this);\n\t\tRooms.global.rejoinGames(this);\n\t\tChat.loginfilter(this, null, userType);\n\t\treturn true;\n\t}\n\tforceRename(name: string, registered: boolean, isForceRenamed = false) {\n\t\t// skip the login server\n\t\tconst userid = toID(name);\n\n\t\tif (users.has(userid) && users.get(userid) !== this) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst oldname = this.name;\n\t\tconst oldid = this.id;\n\t\tif (userid !== this.id) {\n\t\t\tthis.cancelReady();\n\n\t\t\tif (!Users.move(this, userid)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// MMR is different for each userid\n\t\t\tthis.mmrCache = {};\n\n\t\t\tthis.updateGroup(registered);\n\t\t} else if (registered) {\n\t\t\tthis.updateGroup(registered);\n\t\t}\n\n\t\tif (this.named && oldid !== userid && !this.previousIDs.includes(oldid)) this.previousIDs.push(oldid);\n\t\tthis.name = name;\n\n\t\tconst joining = !this.named;\n\t\tthis.named = !userid.startsWith('guest') || !!this.namelocked;\n\n\t\tif (isForceRenamed) this.userMessage = '';\n\n\t\tfor (const connection of this.connections) {\n\t\t\t// console.log(`${name} renaming: socket ${i} of ${this.connections.length}`);\n\t\t\tconnection.send(this.getUpdateuserText());\n\t\t}\n\t\tfor (const roomid of this.games) {\n\t\t\tconst room = Rooms.get(roomid);\n\t\t\tif (!room) {\n\t\t\t\tMonitor.warn(`while renaming, room ${roomid} expired for user ${this.id} in rooms ${[...this.inRooms]} and games ${[...this.games]}`);\n\t\t\t\tthis.games.delete(roomid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!room.game) {\n\t\t\t\tMonitor.warn(`game desync for user ${this.id} in room ${room.roomid}`);\n\t\t\t\tthis.games.delete(roomid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\troom.game.onRename(this, oldid, joining, isForceRenamed);\n\t\t}\n\t\tfor (const roomid of this.inRooms) {\n\t\t\tconst room = Rooms.get(roomid)!;\n\t\t\troom.onRename(this, oldid, joining);\n\t\t\tif (room.game && !this.games.has(roomid)) {\n\t\t\t\tif (room.game.playerTable[this.id]) {\n\t\t\t\t\tthis.games.add(roomid);\n\t\t\t\t\troom.game.onRename(this, oldid, joining, isForceRenamed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (isForceRenamed) this.trackRename = oldname;\n\t\treturn true;\n\t}\n\tgetUpdateuserText() {\n\t\tconst named = this.named ? 1 : 0;\n\t\tconst settings = {\n\t\t\t...this.settings,\n\t\t\t// Battle privacy state needs to be propagated in addition to regular settings so that the\n\t\t\t// 'Ban spectators' checkbox on the client can be kept in sync (and disable privacy correctly)\n\t\t\thiddenNextBattle: this.battleSettings.hidden,\n\t\t\tinviteOnlyNextBattle: this.battleSettings.inviteOnly,\n\t\t\tlanguage: this.language,\n\t\t};\n\t\treturn `|updateuser|${this.getIdentityWithStatus()}|${named}|${this.avatar}|${JSON.stringify(settings)}`;\n\t}\n\tupdate() {\n\t\tthis.send(this.getUpdateuserText());\n\t}\n\t/**\n\t * If Alice logs into Bob's account, and Bob is currently logged into PS,\n\t * their connections will be merged, so that both `Connection`s are attached\n\t * to the Alice `User`.\n\t *\n\t * In this function, `this` is Bob, and `oldUser` is Alice.\n\t *\n\t * This is a pretty routine thing: If Alice opens PS, then opens PS again in\n\t * a new tab, PS will first create a Guest `User`, then automatically log in\n\t * and merge that Guest `User` into the Alice `User` from the first tab.\n\t */\n\tmerge(oldUser: User) {\n\t\toldUser.cancelReady();\n\t\tfor (const roomid of oldUser.inRooms) {\n\t\t\tRooms.get(roomid)!.onLeave(oldUser);\n\t\t}\n\n\t\tconst oldLocked = this.locked;\n\t\tconst oldSemilocked = this.semilocked;\n\n\t\tif (!oldUser.semilocked) this.semilocked = null;\n\n\t\t// If either user is unlocked and neither is locked by name/range, remove the lock.\n\t\t// Otherwise, keep any locks that were by name.\n\t\tif (\n\t\t\t(!oldUser.locked || !this.locked) &&\n\t\t\toldUser.locked !== oldUser.id &&\n\t\t\tthis.locked !== this.id &&\n\t\t\t// Only unlock if no previous names are locked and the lock isn't a rangelock\n\t\t\t!(\n\t\t\t\toldUser.ips.some(x => Punishments.ips.get(x)?.some(n => n.id.startsWith('#'))) &&\n\t\t\t\toldUser.previousIDs.some(id => !!Punishments.hasPunishType(id, 'LOCK'))\n\t\t\t)\n\t\t) {\n\t\t\tthis.locked = null;\n\t\t\tthis.destroyPunishmentTimer();\n\t\t} else if (this.locked !== this.id) {\n\t\t\tthis.locked = oldUser.locked;\n\t\t}\n\t\tif (oldUser.autoconfirmed) this.autoconfirmed = oldUser.autoconfirmed;\n\n\t\tthis.updateGroup(this.registered, true);\n\t\tif (oldLocked !== this.locked || oldSemilocked !== this.semilocked) this.updateIdentity();\n\n\t\t// We only propagate the 'busy' statusType through merging - merging is\n\t\t// active enough that the user should no longer be in the 'idle' state.\n\t\t// Doing this before merging connections ensures the updateuser message\n\t\t// shows the correct idle state.\n\t\tconst isBusy = this.statusType === 'busy' || oldUser.statusType === 'busy';\n\t\tthis.setStatusType(isBusy ? 'busy' : 'online');\n\n\t\tfor (const connection of oldUser.connections) {\n\t\t\tthis.mergeConnection(connection);\n\t\t}\n\t\toldUser.inRooms.clear();\n\t\toldUser.connections = [];\n\n\t\tif (oldUser.chatQueue) {\n\t\t\tif (!this.chatQueue) this.chatQueue = [];\n\t\t\tthis.chatQueue.push(...oldUser.chatQueue);\n\t\t\toldUser.clearChatQueue();\n\t\t\tif (!this.chatQueueTimeout) this.startChatQueue();\n\t\t}\n\n\t\tthis.s1 = oldUser.s1;\n\t\tthis.s2 = oldUser.s2;\n\t\tthis.s3 = oldUser.s3;\n\n\t\t// merge IPs\n\t\tfor (const ip of oldUser.ips) {\n\t\t\tif (!this.ips.includes(ip)) this.ips.push(ip);\n\t\t}\n\n\t\tif (oldUser.isSysop) {\n\t\t\tthis.isSysop = true;\n\t\t\toldUser.isSysop = false;\n\t\t}\n\n\t\toldUser.ips = [];\n\t\tthis.latestIp = oldUser.latestIp;\n\t\tthis.latestHost = oldUser.latestHost;\n\t\tthis.latestHostType = oldUser.latestHostType;\n\t\tthis.userMessage = oldUser.userMessage || this.userMessage || '';\n\n\t\toldUser.markDisconnected();\n\t}\n\tmergeConnection(connection: Connection) {\n\t\t// the connection has changed name to this user's username, and so is\n\t\t// being merged into this account\n\t\tif (!this.connected) {\n\t\t\tthis.connected = true;\n\t\t\tUsers.onlineCount++;\n\t\t}\n\t\tif (connection.connectedAt > this.lastConnected) {\n\t\t\tthis.lastConnected = connection.connectedAt;\n\t\t}\n\t\tthis.connections.push(connection);\n\n\t\t// console.log(`${this.name} merging: connection ${connection.socket.id}`);\n\t\tconnection.send(this.getUpdateuserText());\n\t\tconnection.user = this;\n\t\tfor (const roomid of connection.inRooms) {\n\t\t\tconst room = Rooms.get(roomid)!;\n\t\t\tif (!this.inRooms.has(roomid)) {\n\t\t\t\tif (Punishments.checkNameInRoom(this, room.roomid)) {\n\t\t\t\t\t// the connection was in a room that this user is banned from\n\t\t\t\t\tconnection.sendTo(room.roomid, `|deinit`);\n\t\t\t\t\tconnection.leaveRoom(room);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\troom.onJoin(this, connection);\n\t\t\t\tthis.inRooms.add(roomid);\n\t\t\t}\n\t\t\t// Yes, this is intentionally supposed to call onConnect twice\n\t\t\t// during a normal login. Override onUpdateConnection if you\n\t\t\t// don't want this behavior.\n\t\t\troom.game?.onUpdateConnection?.(this, connection);\n\t\t}\n\t\tthis.updateReady(connection);\n\t}\n\tdebugData() {\n\t\tlet str = `${this.tempGroup}${this.name} (${this.id})`;\n\t\tfor (const [i, connection] of this.connections.entries()) {\n\t\t\tstr += ` socket${i}[`;\n\t\t\tstr += [...connection.inRooms].join(`, `);\n\t\t\tstr += `]`;\n\t\t}\n\t\tif (!this.connected) str += ` (DISCONNECTED)`;\n\t\treturn str;\n\t}\n\t/**\n\t * Updates several group-related attributes for the user, namely:\n\t * User#group, User#registered, User#isStaff, User#trusted\n\t *\n\t * Note that unlike the others, User#trusted isn't reset every\n\t * name change.\n\t */\n\tupdateGroup(registered: boolean, isMerge?: boolean) {\n\t\tif (!registered) {\n\t\t\tthis.registered = false;\n\t\t\tthis.tempGroup = Users.Auth.defaultSymbol();\n\t\t\tthis.isStaff = false;\n\t\t\treturn;\n\t\t}\n\t\tthis.registered = true;\n\t\tif (!isMerge) this.tempGroup = globalAuth.get(this.id);\n\n\t\tUsers.Avatars?.handleLogin(this);\n\n\t\tconst groupInfo = Config.groups[this.tempGroup];\n\t\tthis.isStaff = !!(groupInfo && (groupInfo.lock || groupInfo.root));\n\t\tif (!this.isStaff) {\n\t\t\tconst rank = Rooms.get('staff')?.auth.getDirect(this.id);\n\t\t\tthis.isStaff = !!(rank && rank !== '*' && rank !== Users.Auth.defaultSymbol());\n\t\t}\n\t\tif (this.trusted) {\n\t\t\tif (this.locked && this.permalocked) {\n\t\t\t\tMonitor.log(`[CrisisMonitor] Trusted user '${this.id}' is ${this.permalocked !== this.id ? `an alt of permalocked user '${this.permalocked}'` : `a permalocked user`}, and was automatically demoted from ${this.distrust()}.`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.locked = null;\n\t\t\tthis.namelocked = null;\n\t\t\tthis.destroyPunishmentTimer();\n\t\t}\n\t\tif (this.autoconfirmed && this.semilocked) {\n\t\t\tif (this.semilocked.startsWith('#sharedip')) {\n\t\t\t\tthis.semilocked = null;\n\t\t\t} else if (this.semilocked === '#dnsbl') {\n\t\t\t\tthis.popup(`You are locked because someone using your IP has spammed/hacked other websites. This usually means either you're using a proxy, you're in a country where other people commonly hack, or you have a virus on your computer that's spamming websites.`);\n\t\t\t\tthis.semilocked = '#dnsbl.' as PunishType;\n\t\t\t}\n\t\t}\n\t\tif (this.settings.blockPMs && this.can('lock') && !this.can('bypassall')) this.settings.blockPMs = false;\n\t}\n\t/**\n\t * Set a user's group. Pass (' ', true) to force trusted\n\t * status without giving the user a group.\n\t */\n\tsetGroup(group: GroupSymbol, forceTrusted = false) {\n\t\tif (!group) throw new Error(`Falsy value passed to setGroup`);\n\t\tthis.tempGroup = group;\n\t\tconst groupInfo = Config.groups[this.tempGroup];\n\t\tthis.isStaff = !!(groupInfo && (groupInfo.lock || groupInfo.root));\n\t\tif (!this.isStaff) {\n\t\t\tconst rank = Rooms.get('staff')?.auth.getDirect(this.id);\n\t\t\tthis.isStaff = !!(rank && rank !== '*' && rank !== Users.Auth.defaultSymbol());\n\t\t}\n\t\tRooms.global.checkAutojoin(this);\n\t\tif (this.registered) {\n\t\t\tif (forceTrusted || this.tempGroup !== Users.Auth.defaultSymbol()) {\n\t\t\t\tglobalAuth.set(this.id, this.tempGroup);\n\t\t\t\tthis.trusted = this.id;\n\t\t\t\tthis.autoconfirmed = this.id;\n\t\t\t} else {\n\t\t\t\tglobalAuth.delete(this.id);\n\t\t\t\tthis.trusted = '';\n\t\t\t}\n\t\t}\n\t}\n\t/**\n\t * Demotes a user from anything that grants trusted status.\n\t * Returns an array describing what the user was demoted from.\n\t */\n\tdistrust() {\n\t\tif (!this.trusted) return;\n\t\tconst userid = this.trusted;\n\t\tconst removed = [];\n\t\tconst globalGroup = globalAuth.get(userid);\n\t\tif (globalGroup && globalGroup !== ' ') {\n\t\t\tremoved.push(globalAuth.get(userid));\n\t\t}\n\t\tfor (const room of Rooms.global.chatRooms) {\n\t\t\tif (!room.settings.isPrivate && room.auth.isStaff(userid)) {\n\t\t\t\tlet oldGroup = room.auth.getDirect(userid) as string;\n\t\t\t\tif (oldGroup === ' ') {\n\t\t\t\t\toldGroup = 'whitelist in ';\n\t\t\t\t} else {\n\t\t\t\t\troom.auth.set(userid, '+');\n\t\t\t\t}\n\t\t\t\tremoved.push(`${oldGroup}${room.roomid}`);\n\t\t\t}\n\t\t}\n\t\tthis.trusted = '';\n\t\tglobalAuth.set(userid, Users.Auth.defaultSymbol());\n\t\treturn removed;\n\t}\n\tmarkDisconnected() {\n\t\tif (!this.connected) return;\n\t\tChat.runHandlers('onDisconnect', this);\n\t\tthis.connected = false;\n\t\tUsers.onlineCount--;\n\t\tthis.lastDisconnected = Date.now();\n\t\tif (!this.registered) {\n\t\t\t// for \"safety\"\n\t\t\tthis.tempGroup = Users.Auth.defaultSymbol();\n\t\t\tthis.isSysop = false; // should never happen\n\t\t\tthis.isStaff = false;\n\t\t\t// This isn't strictly necessary since we don't reuse User objects\n\t\t\t// for PS, but just in case.\n\t\t\t// We're not resetting .trusted/.autoconfirmed so those accounts\n\t\t\t// can still be locked after logout.\n\t\t}\n\t\t// NOTE: can't do a this.update(...) at this point because we're no longer connected.\n\t}\n\tonDisconnect(connection: Connection) {\n\t\t// slightly safer to do this here so that we can do this before Conn#user is nulled.\n\t\tif (connection.openPages) {\n\t\t\tfor (const page of connection.openPages) {\n\t\t\t\tChat.handleRoomClose(page as RoomID, this, connection);\n\t\t\t}\n\t\t}\n\t\tfor (const [i, connected] of this.connections.entries()) {\n\t\t\tif (connected === connection) {\n\t\t\t\tthis.connections.splice(i, 1);\n\t\t\t\t// console.log('DISCONNECT: ' + this.id);\n\t\t\t\tif (!this.connections.length) {\n\t\t\t\t\tthis.markDisconnected();\n\t\t\t\t}\n\t\t\t\tfor (const roomid of connection.inRooms) {\n\t\t\t\t\tthis.leaveRoom(Rooms.get(roomid)!, connection);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!this.connections.length) {\n\t\t\tfor (const roomid of this.inRooms) {\n\t\t\t\t// should never happen.\n\t\t\t\tMonitor.debug(`!! room miscount: ${roomid} not left`);\n\t\t\t\tRooms.get(roomid)!.onLeave(this);\n\t\t\t}\n\t\t\t// cleanup\n\t\t\tthis.inRooms.clear();\n\t\t\tif (!this.named && !this.previousIDs.length) {\n\t\t\t\t// user never chose a name (and therefore never talked/battled)\n\t\t\t\t// there's no need to keep track of this user, so we can\n\t\t\t\t// immediately deallocate\n\t\t\t\tthis.destroy();\n\t\t\t} else {\n\t\t\t\tthis.cancelReady();\n\t\t\t}\n\t\t}\n\t}\n\tdisconnectAll() {\n\t\t// Disconnects a user from the server\n\t\tthis.clearChatQueue();\n\t\tlet connection = null;\n\t\tthis.markDisconnected();\n\t\tfor (let i = this.connections.length - 1; i >= 0; i--) {\n\t\t\t// console.log('DESTROY: ' + this.id);\n\t\t\tconnection = this.connections[i];\n\t\t\tfor (const roomid of connection.inRooms) {\n\t\t\t\tthis.leaveRoom(Rooms.get(roomid)!, connection);\n\t\t\t}\n\t\t\tconnection.destroy();\n\t\t}\n\t\tif (this.connections.length) {\n\t\t\t// should never happen\n\t\t\tthrow new Error(`Failed to drop all connections for ${this.id}`);\n\t\t}\n\t\tfor (const roomid of this.inRooms) {\n\t\t\t// should never happen.\n\t\t\tthrow new Error(`Room miscount: ${roomid} not left for ${this.id}`);\n\t\t}\n\t\tthis.inRooms.clear();\n\t}\n\t/**\n\t * If this user is included in the returned list of\n\t * alts (i.e. when forPunishment is true), they will always be the first element of that list.\n\t */\n\tgetAltUsers(includeTrusted = false, forPunishment = false) {\n\t\tlet alts = findUsers([this.getLastId()], this.ips, { includeTrusted, forPunishment });\n\t\talts = alts.filter(user => user !== this);\n\t\tif (forPunishment) alts.unshift(this);\n\t\treturn alts;\n\t}\n\tgetLastName() {\n\t\tif (this.named) return this.name;\n\t\tconst lastName = this.previousIDs.length ? this.previousIDs[this.previousIDs.length - 1] : this.name;\n\t\treturn `[${lastName}]`;\n\t}\n\tgetLastId() {\n\t\tif (this.named) return this.id;\n\t\treturn (this.previousIDs.length ? this.previousIDs[this.previousIDs.length - 1] : this.id);\n\t}\n\tasync tryJoinRoom(roomid: RoomID | Room, connection: Connection) {\n\t\troomid = roomid && (roomid as Room).roomid ? (roomid as Room).roomid : roomid as RoomID;\n\t\tconst room = Rooms.search(roomid);\n\t\tif (!room) {\n\t\t\tif (roomid.startsWith('view-')) {\n\t\t\t\treturn Chat.resolvePage(roomid, this, connection);\n\t\t\t}\n\t\t\tconnection.sendTo(roomid, `|noinit|nonexistent|The room \"${roomid}\" does not exist.`);\n\t\t\treturn false;\n\t\t}\n\t\tif (!room.checkModjoin(this)) {\n\t\t\tif (!this.named) return Rooms.RETRY_AFTER_LOGIN;\n\t\t\tconnection.sendTo(roomid, `|noinit|joinfailed|The room \"${roomid}\" is invite-only, and you haven't been invited.`);\n\t\t\treturn false;\n\t\t}\n\t\tif ((room as GameRoom).tour) {\n\t\t\tconst errorMessage = (room as GameRoom).tour!.onBattleJoin(room as GameRoom, this);\n\t\t\tif (errorMessage) {\n\t\t\t\tconnection.sendTo(roomid, `|noinit|joinfailed|${errorMessage}`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif (room.settings.isPrivate) {\n\t\t\tif (!this.named) {\n\t\t\t\treturn Rooms.RETRY_AFTER_LOGIN;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.can('bypassall') && Punishments.isRoomBanned(this, room.roomid)) {\n\t\t\tconnection.sendTo(roomid, `|noinit|joinfailed|You are banned from the room \"${roomid}\".`);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (room.roomid.startsWith('groupchat-') && !room.parent) {\n\t\t\tconst groupchatbanned = Punishments.isGroupchatBanned(this);\n\t\t\tif (groupchatbanned) {\n\t\t\t\tconst expireText = Punishments.checkPunishmentExpiration(groupchatbanned);\n\t\t\t\tconnection.sendTo(roomid, `|noinit|joinfailed|You are banned from using groupchats${expireText}.`);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tPunishments.monitorGroupchatJoin(room, this);\n\t\t}\n\n\t\tif (Rooms.aliases.get(roomid) === room.roomid) {\n\t\t\tconnection.send(`>${roomid}\\n|deinit`);\n\t\t}\n\n\t\tthis.joinRoom(room, connection);\n\t\treturn true;\n\t}\n\tjoinRoom(roomid: RoomID | Room, connection: Connection | null = null) {\n\t\tconst room = Rooms.get(roomid);\n\t\tif (!room) throw new Error(`Room not found: ${roomid}`);\n\t\tif (!connection) {\n\t\t\tfor (const curConnection of this.connections) {\n\t\t\t\tthis.joinRoom(room, curConnection);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (!connection.inRooms.has(room.roomid)) {\n\t\t\tif (!this.inRooms.has(room.roomid)) {\n\t\t\t\troom.onJoin(this, connection);\n\t\t\t\tthis.inRooms.add(room.roomid);\n\t\t\t}\n\t\t\tconnection.joinRoom(room);\n\t\t\troom.onConnect(this, connection);\n\t\t}\n\t}\n\tleaveRoom(room: Room | string, connection: Connection | null = null) {\n\t\troom = Rooms.get(room)!;\n\t\tif (!this.inRooms.has(room.roomid)) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (const curConnection of this.connections) {\n\t\t\tif (connection && curConnection !== connection) continue;\n\t\t\tif (curConnection.inRooms.has(room.roomid)) {\n\t\t\t\tcurConnection.sendTo(room.roomid, `|deinit`);\n\t\t\t\tcurConnection.leaveRoom(room);\n\t\t\t}\n\t\t\tif (connection) break;\n\t\t}\n\n\t\tlet stillInRoom = false;\n\t\tif (connection) {\n\t\t\tstillInRoom = this.connections.some(conn => conn.inRooms.has(room.roomid));\n\t\t}\n\t\tif (!stillInRoom) {\n\t\t\troom.onLeave(this);\n\t\t\tthis.inRooms.delete(room.roomid);\n\t\t}\n\t}\n\n\tcancelReady() {\n\t\t// setting variables because this can't be short-circuited\n\t\tconst searchesCancelled = Ladders.cancelSearches(this);\n\t\tconst challengesCancelled = Ladders.challenges.clearFor(this.id, 'they changed their username');\n\t\tif (searchesCancelled || challengesCancelled) {\n\t\t\tthis.popup(`Your searches and challenges have been cancelled because you changed your username.`);\n\t\t}\n\t\t// cancel tour challenges\n\t\t// no need for a popup because users can't change their name while in a tournament anyway\n\t\tfor (const roomid of this.games) {\n\t\t\t// @ts-expect-error Tournaments aren't TS'd yet\n\t\t\tRooms.get(roomid)?.game?.cancelChallenge?.(this);\n\t\t}\n\t}\n\tupdateReady(connection: Connection | null = null) {\n\t\tLadders.updateSearch(this, connection);\n\t\tLadders.challenges.updateFor(connection || this);\n\t}\n\tupdateSearch(connection: Connection | null = null) {\n\t\tLadders.updateSearch(this, connection);\n\t}\n\t/**\n\t * Moves the user's connections in a given room to another room.\n\t * This function's main use case is for when a room is renamed.\n\t */\n\tmoveConnections(oldRoomID: RoomID, newRoomID: RoomID) {\n\t\tthis.inRooms.delete(oldRoomID);\n\t\tthis.inRooms.add(newRoomID);\n\t\tfor (const connection of this.connections) {\n\t\t\tconnection.inRooms.delete(oldRoomID);\n\t\t\tconnection.inRooms.add(newRoomID);\n\t\t\tSockets.roomRemove(connection.worker, oldRoomID, connection.socketid);\n\t\t\tSockets.roomAdd(connection.worker, newRoomID, connection.socketid);\n\t\t}\n\t}\n\t/**\n\t * The user says message in room.\n\t * Returns false if the rest of the user's messages should be discarded.\n\t */\n\tchat(message: string, room: Room | null, connection: Connection) {\n\t\tconst now = Date.now();\n\t\tconst noThrottle = this.hasSysopAccess() || Config.nothrottle;\n\n\t\tif (message.startsWith('/cmd userdetails') || message.startsWith('>> ') || noThrottle) {\n\t\t\t// certain commands are exempt from the queue\n\t\t\tMonitor.activeIp = connection.ip;\n\t\t\tChat.parse(message, room, this, connection);\n\t\t\tMonitor.activeIp = null;\n\t\t\tif (noThrottle) return;\n\t\t\treturn false; // but end the loop here\n\t\t}\n\n\t\tconst throttleDelay = this.isPublicBot ? THROTTLE_DELAY_PUBLIC_BOT : this.trusted ? THROTTLE_DELAY_TRUSTED :\n\t\t\tTHROTTLE_DELAY;\n\n\t\tif (this.chatQueueTimeout) {\n\t\t\tif (!this.chatQueue) this.chatQueue = []; // this should never happen\n\t\t\tif (this.chatQueue.length >= THROTTLE_BUFFER_LIMIT - 1) {\n\t\t\t\tconnection.sendTo(\n\t\t\t\t\troom,\n\t\t\t\t\t`|raw|<strong class=\"message-throttle-notice\">Your message was not sent because you've been typing too quickly.</strong>`\n\t\t\t\t);\n\t\t\t\treturn false;\n\t\t\t} else {\n\t\t\t\tthis.chatQueue.push([message, room ? room.roomid : '', connection]);\n\t\t\t}\n\t\t} else if (now < this.lastChatMessage + throttleDelay) {\n\t\t\tthis.chatQueue = [[message, room ? room.roomid : '', connection]];\n\t\t\tthis.startChatQueue(throttleDelay - (now - this.lastChatMessage));\n\t\t} else {\n\t\t\tthis.lastChatMessage = now;\n\t\t\tMonitor.activeIp = connection.ip;\n\t\t\tChat.parse(message, room, this, connection);\n\t\t\tMonitor.activeIp = null;\n\t\t}\n\t}\n\tstartChatQueue(delay: number | null = null) {\n\t\tif (delay === null) {\n\t\t\tdelay = (this.isPublicBot ? THROTTLE_DELAY_PUBLIC_BOT : this.trusted ? THROTTLE_DELAY_TRUSTED :\n\t\t\t\tTHROTTLE_DELAY) - (Date.now() - this.lastChatMessage);\n\t\t}\n\n\t\tthis.chatQueueTimeout = setTimeout(\n\t\t\t() => this.processChatQueue(),\n\t\t\tdelay\n\t\t);\n\t}\n\tclearChatQueue() {\n\t\tthis.chatQueue = null;\n\t\tif (this.chatQueueTimeout) {\n\t\t\tclearTimeout(this.chatQueueTimeout);\n\t\t\tthis.chatQueueTimeout = null;\n\t\t}\n\t}\n\tprocessChatQueue(): void {\n\t\tthis.chatQueueTimeout = null;\n\t\tif (!this.chatQueue) return;\n\t\tconst queueElement = this.chatQueue.shift();\n\t\tif (!queueElement) {\n\t\t\tthis.chatQueue = null;\n\t\t\treturn;\n\t\t}\n\t\tconst [message, roomid, connection] = queueElement;\n\t\tif (!connection.user) {\n\t\t\t// connection disconnected, chat queue should not be big enough\n\t\t\t// for recursion to be an issue, also didn't ES6 spec tail\n\t\t\t// recursion at some point?\n\t\t\treturn this.processChatQueue();\n\t\t}\n\n\t\tthis.lastChatMessage = new Date().getTime();\n\n\t\tconst room = Rooms.get(roomid);\n\t\tif (room || !roomid) {\n\t\t\tMonitor.activeIp = connection.ip;\n\t\t\tChat.parse(message, room, this, connection);\n\t\t\tMonitor.activeIp = null;\n\t\t} else {\n\t\t\t// room no longer exists; do nothing\n\t\t}\n\n\t\tconst throttleDelay = this.isPublicBot ? THROTTLE_DELAY_PUBLIC_BOT : this.trusted ? THROTTLE_DELAY_TRUSTED :\n\t\t\tTHROTTLE_DELAY;\n\n\t\tif (this.chatQueue.length) {\n\t\t\tthis.chatQueueTimeout = setTimeout(() => this.processChatQueue(), throttleDelay);\n\t\t} else {\n\t\t\tthis.chatQueue = null;\n\t\t}\n\t}\n\tsetStatusType(type: StatusType) {\n\t\tif (type === this.statusType) return;\n\t\tthis.statusType = type;\n\t\tthis.updateIdentity();\n\t\tthis.update();\n\t}\n\tsetUserMessage(message: string) {\n\t\tif (message === this.userMessage) return;\n\t\tthis.userMessage = message;\n\t\tthis.updateIdentity();\n\t}\n\tclearStatus(type: StatusType = this.statusType) {\n\t\tthis.statusType = type;\n\t\tthis.userMessage = '';\n\t\tthis.updateIdentity();\n\t}\n\tgetAccountStatusString() {\n\t\treturn this.trusted === this.id ? `[trusted]` :\n\t\t\tthis.autoconfirmed === this.id ? `[ac]` :\n\t\t\tthis.registered ? `[registered]` :\n\t\t\t``;\n\t}\n\tdestroy() {\n\t\t// deallocate user\n\t\tfor (const roomid of this.games) {\n\t\t\tconst game = Rooms.get(roomid)?.game;\n\t\t\tif (!game) {\n\t\t\t\tMonitor.warn(`while deallocating, room ${roomid} did not have a game for ${this.id} in rooms ${[...this.inRooms]} and games ${[...this.games]}`);\n\t\t\t\tthis.games.delete(roomid);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!game.ended) game.forfeit?.(this, \" lost by being offline too long.\");\n\t\t}\n\t\tthis.clearChatQueue();\n\t\tthis.destroyPunishmentTimer();\n\t\tUsers.delete(this);\n\t}\n\tdestroyPunishmentTimer() {\n\t\tif (this.punishmentTimer) {\n\t\t\tclearTimeout(this.punishmentTimer);\n\t\t\tthis.punishmentTimer = null;\n\t\t}\n\t}\n\toverride toString() {\n\t\treturn this.id;\n\t}\n}\n\n/*********************************************************\n * Inactive user pruning\n *********************************************************/\n\nfunction pruneInactive(threshold: number) {\n\tconst now = Date.now();\n\tfor (const user of users.values()) {\n\t\tif (user.statusType === 'online') {\n\t\t\t// check if we should set status to idle\n\t\t\tconst awayTimer = user.can('lock') ? STAFF_IDLE_TIMER : IDLE_TIMER;\n\t\t\tconst bypass = !user.can('bypassall') && (\n\t\t\t\tuser.can('bypassafktimer') ||\n\t\t\t\tArray.from(user.inRooms).some(room => user.can('bypassafktimer', null, Rooms.get(room)!))\n\t\t\t);\n\t\t\tif (!bypass && !user.connections.some(connection => now - connection.lastActiveTime < awayTimer)) {\n\t\t\t\tuser.setStatusType('idle');\n\t\t\t}\n\t\t}\n\t\tif (!user.connected && (now - user.lastDisconnected) > threshold) {\n\t\t\tuser.destroy();\n\t\t}\n\t\tif (!user.can('addhtml')) {\n\t\t\tconst suspicious = global.Config?.isSuspicious?.(user) || false;\n\t\t\tfor (const connection of user.connections) {\n\t\t\t\tif (\n\t\t\t\t\t// conn's been inactive for 24h, just kill it\n\t\t\t\t\t(now - connection.lastActiveTime > CONNECTION_EXPIRY_TIME) ||\n\t\t\t\t\t// they're connected and not named, but not namelocked. this is unusual behavior, ultimately just wasting resources.\n\t\t\t\t\t// people have been spamming us with conns as of writing this, so it appears to be largely bots doing this.\n\t\t\t\t\t// so we're just gonna go ahead and dc them. if they're a real user, they can rejoin and go back to... whatever.\n\t\t\t\t\tsuspicious && (now - connection.connectedAt) > threshold\n\t\t\t\t) {\n\t\t\t\t\tconnection.destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction logGhostConnections(threshold: number): Promise<unknown> {\n\tconst buffer = [];\n\tfor (const connection of connections.values()) {\n\t\t// If the connection's been around for at least a week and it doesn't\n\t\t// use raw WebSockets (which doesn't have any kind of keepalive or\n\t\t// timeouts on it), log it.\n\t\tif (connection.protocol !== 'websocket-raw' && connection.connectedAt <= Date.now() - threshold) {\n\t\t\tconst timestamp = Chat.toTimestamp(new Date(connection.connectedAt));\n\t\t\tconst now = Chat.toTimestamp(new Date());\n\t\t\tconst log = `Connection ${connection.id} from ${connection.ip} with protocol \"${connection.protocol}\" has been around since ${timestamp} (currently ${now}).`;\n\t\t\tbuffer.push(log);\n\t\t}\n\t}\n\treturn buffer.length ?\n\t\tMonitor.logPath(`ghosts-${process.pid}.log`).append(buffer.join('\\r\\n') + '\\r\\n') :\n\t\tPromise.resolve();\n}\n\n/*********************************************************\n * Routing\n *********************************************************/\n\nfunction socketConnect(\n\tworker: ProcessManager.StreamWorker,\n\tworkerid: number,\n\tsocketid: string,\n\tip: string,\n\tprotocol: string\n) {\n\tconst id = `${workerid}-${socketid}`;\n\tconst connection = new Connection(id, worker, socketid, null, ip, protocol);\n\tconnections.set(id, connection);\n\n\tconst banned = Punishments.checkIpBanned(connection);\n\tif (banned) {\n\t\treturn connection.destroy();\n\t}\n\t// Emergency mode connections logging\n\tif (Config.emergency) {\n\t\tvoid Monitor.logPath('cons.emergency.log').append('[' + ip + ']\\n');\n\t}\n\n\tconst user = new User(connection);\n\tconnection.user = user;\n\tvoid Punishments.checkIp(user, connection);\n\t// Generate 1024-bit challenge string.\n\trequire('crypto').randomBytes(128, (err: Error | null, buffer: Buffer) => {\n\t\tif (err) {\n\t\t\t// It's not clear what sort of condition could cause this.\n\t\t\t// For now, we'll basically assume it can't happen.\n\t\t\tMonitor.crashlog(err, 'randomBytes');\n\t\t\t// This is pretty crude, but it's the easiest way to deal\n\t\t\t// with this case, which should be impossible anyway.\n\t\t\tuser.disconnectAll();\n\t\t} else if (connection.user) {\t// if user is still connected\n\t\t\tconnection.challenge = buffer.toString('hex');\n\t\t\t// console.log('JOIN: ' + connection.user.name + ' [' + connection.challenge.substr(0, 15) + '] [' + socket.id + ']');\n\t\t\tconst keyid = Config.loginserverpublickeyid || 0;\n\t\t\tconnection.sendTo(null, `|challstr|${keyid}|${connection.challenge}`);\n\t\t}\n\t});\n\n\tRooms.global.handleConnect(user, connection);\n}\nfunction socketDisconnect(worker: ProcessManager.StreamWorker, workerid: number, socketid: string) {\n\tconst id = `${workerid}-${socketid}`;\n\n\tconst connection = connections.get(id);\n\tif (!connection) return;\n\tconnection.onDisconnect();\n}\nfunction socketDisconnectAll(worker: ProcessManager.StreamWorker, workerid: number) {\n\tfor (const connection of connections.values()) {\n\t\tif (connection.worker === worker) {\n\t\t\tconnection.onDisconnect();\n\t\t}\n\t}\n}\nfunction socketReceive(worker: ProcessManager.StreamWorker, workerid: number, socketid: string, message: string) {\n\tconst id = `${workerid}-${socketid}`;\n\n\tconst connection = connections.get(id);\n\tif (!connection) return;\n\tconnection.lastActiveTime = Date.now();\n\n\t// Due to a bug in SockJS or Faye, if an exception propagates out of\n\t// the `data` event handler, the user will be disconnected on the next\n\t// `data` event. To prevent this, we log exceptions and prevent them\n\t// from propagating out of this function.\n\n\t// drop legacy JSON messages\n\tif (message.startsWith('{')) return;\n\n\tconst pipeIndex = message.indexOf('|');\n\tif (pipeIndex < 0) {\n\t\t// drop invalid messages without a pipe character\n\t\tconnection.popup(`Invalid message; messages should be in the format \\`ROOMID|MESSAGE\\`. See https://github.com/smogon/pokemon-showdown/blob/master/PROTOCOL.md`);\n\t\treturn;\n\t}\n\n\tconst user = connection.user;\n\tif (!user) return;\n\n\t// LEGACY: In the past, an empty room ID would default to Lobby,\n\t// but that is no longer supported\n\tconst roomId = message.slice(0, pipeIndex) || '';\n\tmessage = message.slice(pipeIndex + 1);\n\n\tconst room = Rooms.get(roomId) || null;\n\tconst multilineMessage = Chat.multiLinePattern.test(message);\n\tif (multilineMessage) {\n\t\tuser.chat(multilineMessage, room, connection);\n\t\treturn;\n\t}\n\n\tconst lines = message.split('\\n');\n\tif (!lines[lines.length - 1]) lines.pop();\n\tconst maxLineCount = (\n\t\tuser.can('bypassall') ? THROTTLE_MULTILINE_WARN_ADMIN :\n\t\t(user.isStaff || room?.auth.isStaff(user.id)) ?\n\t\t\tTHROTTLE_MULTILINE_WARN_STAFF : THROTTLE_MULTILINE_WARN\n\t);\n\tif (lines.length > maxLineCount && !Config.nothrottle) {\n\t\tconnection.popup(`You're sending too many lines at once. Try using a paste service like [[Pastebin]].`);\n\t\treturn;\n\t}\n\t// Emergency logging\n\tif (Config.emergency) {\n\t\tvoid Monitor.logPath('emergency.log').append(`[${user} (${connection.ip})] ${roomId}|${message}\\n`);\n\t}\n\n\tfor (const line of lines) {\n\t\tif (user.chat(line, room, connection) === false) break;\n\t}\n}\n\nconst users = new Map<ID, User>();\nconst prevUsers = new Map<ID, ID>();\nlet numUsers = 0;\n\nexport const Users = {\n\tdelete: deleteUser,\n\tmove,\n\tadd,\n\tmerge,\n\tusers,\n\tprevUsers,\n\tonlineCount: 0,\n\tget: getUser,\n\tgetExact: getExactUser,\n\tfindUsers,\n\tAuth,\n\tAvatars: null as typeof import('./chat-commands/avatars').Avatars | null,\n\tglobalAuth,\n\tisUsernameKnown,\n\tisUsername,\n\tisTrusted,\n\tisPublicBot,\n\tPLAYER_SYMBOL,\n\tHOST_SYMBOL,\n\tconnections,\n\tUser,\n\tConnection,\n\tsocketDisconnect,\n\tsocketDisconnectAll,\n\tsocketReceive,\n\tpruneInactive,\n\tpruneInactiveTimer: setInterval(() => {\n\t\tpruneInactive(Config.inactiveuserthreshold || 60 * MINUTES);\n\t}, 30 * MINUTES),\n\tlogGhostConnections,\n\tlogGhostConnectionsTimer: setInterval(() => {\n\t\tvoid logGhostConnections(7 * 24 * 60 * MINUTES);\n\t}, 7 * 24 * 60 * MINUTES),\n\tsocketConnect,\n};\n"],
  "mappings": "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",
  "names": []
}
