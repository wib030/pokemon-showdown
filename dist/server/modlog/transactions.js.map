{
  "version": 3,
  "sources": ["../../../server/modlog/transactions.ts"],
  "sourcesContent": ["/**\n * SQL transactions for the modlog.\n */\n\nimport type { TransactionEnvironment } from '../../lib/sql';\nimport type { TransactionArguments } from '.';\n\nexport const transactions = {\n\tinsertion: (args: TransactionArguments, env: TransactionEnvironment) => {\n\t\tconst modlogInsertion = env.statements.get(args.modlogInsertionStatement);\n\t\tconst altsInsertion = env.statements.get(args.altsInsertionStatement);\n\t\tif (!modlogInsertion) {\n\t\t\tthrow new Error(`Couldn't find prepared statement for provided value (args.modlogInsertionStatement=${args.modlogInsertionStatement}`);\n\t\t}\n\t\tif (!altsInsertion) {\n\t\t\tthrow new Error(`Couldn't find prepared statement for provided value (args.altsInsertionStatement=${args.altsInsertionStatement}`);\n\t\t}\n\n\t\tfor (const entry of args.entries) {\n\t\t\t// SQLite doesn't have a boolean type, so this is a workaround.\n\t\t\tentry.isGlobal = Number(entry.isGlobal) as any;\n\t\t\tconst result = modlogInsertion.run(entry);\n\t\t\tconst rowid = result.lastInsertRowid as number;\n\n\t\t\tfor (const alt of entry.alts || []) {\n\t\t\t\taltsInsertion.run(rowid, alt);\n\t\t\t}\n\t\t}\n\t},\n};\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAOO,MAAM,eAAe;AAAA,EAC3B,WAAW,CAAC,MAA4B,QAAgC;AACvE,UAAM,kBAAkB,IAAI,WAAW,IAAI,KAAK,wBAAwB;AACxE,UAAM,gBAAgB,IAAI,WAAW,IAAI,KAAK,sBAAsB;AACpE,QAAI,CAAC,iBAAiB;AACrB,YAAM,IAAI,MAAM,sFAAsF,KAAK,wBAAwB,EAAE;AAAA,IACtI;AACA,QAAI,CAAC,eAAe;AACnB,YAAM,IAAI,MAAM,oFAAoF,KAAK,sBAAsB,EAAE;AAAA,IAClI;AAEA,eAAW,SAAS,KAAK,SAAS;AAEjC,YAAM,WAAW,OAAO,MAAM,QAAQ;AACtC,YAAM,SAAS,gBAAgB,IAAI,KAAK;AACxC,YAAM,QAAQ,OAAO;AAErB,iBAAW,OAAO,MAAM,QAAQ,CAAC,GAAG;AACnC,sBAAc,IAAI,OAAO,GAAG;AAAA,MAC7B;AAAA,IACD;AAAA,EACD;AACD;",
  "names": []
}
