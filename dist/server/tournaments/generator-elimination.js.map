{
  "version": 3,
  "sources": ["../../../server/tournaments/generator-elimination.ts"],
  "sourcesContent": ["import { Utils } from '../../lib';\n\ninterface ElimTree {\n\troot: ElimNode;\n\tcurrentLayerLeafNodes: ElimNode[];\n\tnextLayerLeafNodes: ElimNode[];\n}\n\nimport type { TournamentPlayer } from './index';\n\n/**\n * There are two types of elim nodes, player nodes\n * and match nodes.\n *\n * Player nodes are leaf nodes: .children = none\n *\n * Match nodes are non-leaf nodes, and will always have two children.\n */\nclass ElimNode {\n\tchildren: [ElimNode, ElimNode] | null;\n\t/**\n\t * In a player node, the player (null if it's an unfilled loser's bracket node).\n\t *\n\t * In a match node, the winner if it exists, otherwise null.\n\t */\n\tuser: TournamentPlayer | null;\n\t/**\n\t * Only relevant to match nodes. (Player nodes are always '')\n\t *\n\t * 'available' = ready for battles - will have two children, both with users; this.user is null\n\t *\n\t * 'finished' = battle already over - will have two children, both with users; this.user is winner\n\t *\n\t * '' = unavailable\n\t */\n\tstate: 'available' | 'finished' | '';\n\tresult: 'win' | 'loss' | '';\n\tscore: number[] | null;\n\t/**\n\t * Only relevant to match nodes in double+ elimination.\n\t *\n\t * The loser of this battle will be put in target player node.\n\t */\n\tlosersBracketNode: ElimNode | null;\n\t/**\n\t * 0 = winner's bracket\n\t * 1 = loser's bracket\n\t * 2 = second loser's bracket\n\t * etc\n\t * (always 0 in single elimination)\n\t */\n\tlosersBracketIndex: number;\n\tparent: ElimNode | null;\n\t/**\n\t * Only used while building the tree\n\t */\n\tfromNode: ElimNode | null;\n\tconstructor(options: Partial<ElimNode>) {\n\t\tthis.children = null;\n\t\tthis.user = options.user || null;\n\t\tthis.state = options.state || '';\n\t\tthis.result = options.result || '';\n\t\tthis.score = options.score || null;\n\t\tthis.losersBracketNode = options.losersBracketNode || null;\n\t\tthis.losersBracketIndex = options.losersBracketIndex || 0;\n\t\tthis.parent = options.parent || null;\n\t\tthis.fromNode = options.fromNode || null;\n\t}\n\tsetChildren(children: [ElimNode, ElimNode] | null) {\n\t\tif (this.children) {\n\t\t\tfor (const child of this.children) child.parent = null;\n\t\t}\n\t\tif (children) {\n\t\t\tfor (const child of children) child.parent = this;\n\t\t}\n\t\tthis.children = children;\n\t}\n\ttraverse(multiCallback: (node: ElimNode) => void) {\n\t\tconst queue: ElimNode[] = [this];\n\t\tlet node;\n\t\twhile ((node = queue.shift())) {\n\t\t\tmultiCallback(node);\n\t\t\tif (node.children) queue.push(...node.children);\n\t\t}\n\t}\n\tfind<T>(multiCallback: (node: ElimNode) => (T | void)) {\n\t\tconst queue: ElimNode[] = [this];\n\t\tlet node;\n\t\twhile ((node = queue.shift())) {\n\t\t\tconst value = multiCallback(node);\n\t\t\tif (value) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (node.children) queue.push(...node.children);\n\t\t}\n\t\treturn undefined;\n\t}\n\t[Symbol.iterator]() {\n\t\tconst results: ElimNode[] = [this];\n\t\tfor (const result of results) {\n\t\t\tif (result.children) results.push(...result.children);\n\t\t}\n\t\treturn results[Symbol.iterator]();\n\t}\n\ttoJSON() {\n\t\tconst node: any = {};\n\n\t\tif (!this.children) {\n\t\t\tnode.team = this.user || (\n\t\t\t\tthis.losersBracketIndex <= 1 ? `(loser's bracket)` : `(loser's bracket ${this.losersBracketIndex})`\n\t\t\t);\n\t\t} else {\n\t\t\tnode.children = this.children.map(child => child.toJSON());\n\t\t\tnode.state = this.state || 'unavailable';\n\t\t\tif (node.state === 'finished') {\n\t\t\t\tnode.team = this.user;\n\t\t\t\tnode.result = this.result;\n\t\t\t\tnode.score = this.score;\n\t\t\t}\n\t\t}\n\n\t\treturn node;\n\t}\n}\n\nconst nameMap = [\n\t\"\",\n\t\"Single\",\n\t\"Double\",\n\t\"Triple\",\n\t\"Quadruple\",\n\t\"Quintuple\",\n\t\"Sextuple\",\n\t// Feel free to add more\n];\n\nexport class Elimination {\n\treadonly name: string;\n\treadonly isDrawingSupported: boolean;\n\tisBracketFrozen: boolean;\n\tplayers: TournamentPlayer[];\n\tmaxSubtrees: number;\n\ttreeRoot: ElimNode;\n\tconstructor(maxSubtrees: number | string) {\n\t\tthis.name = \"Elimination\";\n\t\tthis.isDrawingSupported = false;\n\t\tthis.isBracketFrozen = false;\n\t\tthis.players = [];\n\n\t\tmaxSubtrees = maxSubtrees || 1;\n\t\tif (typeof maxSubtrees === 'string' && maxSubtrees.toLowerCase() === 'infinity') {\n\t\t\tmaxSubtrees = Infinity;\n\t\t} else if (typeof maxSubtrees !== 'number') {\n\t\t\tmaxSubtrees = parseInt(maxSubtrees);\n\t\t}\n\t\tif (!maxSubtrees || maxSubtrees < 1) maxSubtrees = 1;\n\n\t\tthis.maxSubtrees = maxSubtrees;\n\t\tthis.treeRoot = null!;\n\n\t\tif (nameMap[maxSubtrees]) {\n\t\t\tthis.name = `${nameMap[maxSubtrees]} ${this.name}`;\n\t\t} else if (maxSubtrees === Infinity) {\n\t\t\tthis.name = `N-${this.name}`;\n\t\t} else {\n\t\t\tthis.name = `${maxSubtrees}-tuple ${this.name}`;\n\t\t}\n\t}\n\n\tgetPendingBracketData(players: TournamentPlayer[]) {\n\t\treturn {\n\t\t\ttype: 'tree',\n\t\t\trootNode: null,\n\t\t};\n\t}\n\tgetBracketData() {\n\t\treturn {\n\t\t\ttype: 'tree',\n\t\t\trootNode: this.treeRoot.toJSON(),\n\t\t};\n\t}\n\tfreezeBracket(players: TournamentPlayer[]) {\n\t\tif (!players.length) throw new Error(`No players in tournament`);\n\n\t\tthis.players = players;\n\t\tthis.isBracketFrozen = true;\n\n\t\t// build the winner's bracket\n\t\tlet tree: ElimTree = null!;\n\n\t\tfor (const user of Utils.shuffle(players)) {\n\t\t\tif (!tree) {\n\t\t\t\ttree = {\n\t\t\t\t\troot: new ElimNode({ user }),\n\t\t\t\t\tcurrentLayerLeafNodes: [],\n\t\t\t\t\tnextLayerLeafNodes: [],\n\t\t\t\t};\n\t\t\t\ttree.currentLayerLeafNodes.push(tree.root);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst targetNode = tree.currentLayerLeafNodes.shift();\n\t\t\tif (!targetNode) throw new Error(`TypeScript bug: no ! in checkJs`);\n\n\t\t\tconst newLeftChild = new ElimNode({ user: targetNode.user });\n\t\t\ttree.nextLayerLeafNodes.push(newLeftChild);\n\n\t\t\tconst newRightChild = new ElimNode({ user });\n\t\t\ttree.nextLayerLeafNodes.push(newRightChild);\n\t\t\ttargetNode.setChildren([newLeftChild, newRightChild]);\n\n\t\t\ttargetNode.user = null;\n\n\t\t\tif (tree.currentLayerLeafNodes.length === 0) {\n\t\t\t\ttree.currentLayerLeafNodes = tree.nextLayerLeafNodes;\n\t\t\t\ttree.nextLayerLeafNodes = [];\n\t\t\t}\n\t\t}\n\n\t\t// build the loser's brackets, if applicable\n\n\t\tthis.maxSubtrees = Math.min(this.maxSubtrees, players.length - 1);\n\t\tfor (let losersBracketIndex = 1; losersBracketIndex < this.maxSubtrees; losersBracketIndex++) {\n\t\t\tconst matchesByDepth: { [depth: number]: ElimNode[] } = {};\n\t\t\tconst queue = [{ node: tree.root, depth: 0 }];\n\t\t\tlet frame;\n\t\t\twhile ((frame = queue.shift())) {\n\t\t\t\tif (!frame.node.children || frame.node.losersBracketNode) continue;\n\n\t\t\t\tif (!matchesByDepth[frame.depth]) matchesByDepth[frame.depth] = [];\n\t\t\t\tmatchesByDepth[frame.depth].push(frame.node);\n\n\t\t\t\tqueue.push({ node: frame.node.children[0], depth: frame.depth + 1 });\n\t\t\t\tqueue.push({ node: frame.node.children[1], depth: frame.depth + 1 });\n\t\t\t}\n\n\t\t\tconst newTree: ElimTree = {\n\t\t\t\troot: new ElimNode({ losersBracketIndex, fromNode: matchesByDepth[0][0] }),\n\t\t\t\tcurrentLayerLeafNodes: [],\n\t\t\t\tnextLayerLeafNodes: [],\n\t\t\t};\n\t\t\tnewTree.currentLayerLeafNodes.push(newTree.root);\n\n\t\t\tfor (const depth in matchesByDepth) {\n\t\t\t\tif (depth === '0') continue;\n\t\t\t\tconst matchesThisDepth = matchesByDepth[depth];\n\t\t\t\tlet n = 0;\n\t\t\t\tfor (; n < matchesThisDepth.length - 1; n += 2) {\n\t\t\t\t\t// Replace old leaf with:\n\t\t\t\t\t//      old leaf --+\n\t\t\t\t\t//   new leaf --+  +-->\n\t\t\t\t\t//              +--+\n\t\t\t\t\t//   new leaf --+\n\n\t\t\t\t\tconst oldLeaf = newTree.currentLayerLeafNodes.shift();\n\t\t\t\t\tif (!oldLeaf) throw new Error(`TypeScript bug: no ! in checkJs`);\n\t\t\t\t\tconst oldLeafFromNode = oldLeaf.fromNode;\n\t\t\t\t\toldLeaf.fromNode = null;\n\n\t\t\t\t\tconst newBranch = new ElimNode({ losersBracketIndex });\n\t\t\t\t\toldLeaf.setChildren([new ElimNode({ losersBracketIndex, fromNode: oldLeafFromNode }), newBranch]);\n\n\t\t\t\t\tconst newLeftChild = new ElimNode({ losersBracketIndex, fromNode: matchesThisDepth[n] });\n\t\t\t\t\tnewTree.nextLayerLeafNodes.push(newLeftChild);\n\n\t\t\t\t\tconst newRightChild = new ElimNode({ losersBracketIndex, fromNode: matchesThisDepth[n + 1] });\n\t\t\t\t\tnewTree.nextLayerLeafNodes.push(newRightChild);\n\t\t\t\t\tnewBranch.setChildren([newLeftChild, newRightChild]);\n\t\t\t\t}\n\t\t\t\tif (n < matchesThisDepth.length) {\n\t\t\t\t\t// Replace old leaf with:\n\t\t\t\t\t//   old leaf --+\n\t\t\t\t\t//              +-->\n\t\t\t\t\t//   new leaf --+\n\n\t\t\t\t\tconst oldLeaf = newTree.currentLayerLeafNodes.shift()!;\n\t\t\t\t\tconst oldLeafFromNode = oldLeaf.fromNode;\n\t\t\t\t\toldLeaf.fromNode = null;\n\n\t\t\t\t\tconst newLeaf = new ElimNode({ fromNode: matchesThisDepth[n] });\n\t\t\t\t\tnewTree.nextLayerLeafNodes.push(newLeaf);\n\t\t\t\t\toldLeaf.setChildren([new ElimNode({ fromNode: oldLeafFromNode }), newLeaf]);\n\t\t\t\t}\n\n\t\t\t\tnewTree.currentLayerLeafNodes = newTree.nextLayerLeafNodes;\n\t\t\t\tnewTree.nextLayerLeafNodes = [];\n\t\t\t}\n\n\t\t\tnewTree.root.traverse(node => {\n\t\t\t\tif (node.fromNode) {\n\t\t\t\t\tnode.fromNode.losersBracketNode = node;\n\t\t\t\t\tnode.fromNode = null;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst newRoot = new ElimNode({});\n\t\t\tnewRoot.setChildren([tree.root, newTree.root]);\n\t\t\ttree.root = newRoot;\n\t\t}\n\n\t\ttree.root.traverse(node => {\n\t\t\tif (node.children?.[0].user && node.children[1].user) {\n\t\t\t\tnode.state = 'available';\n\t\t\t}\n\t\t});\n\n\t\tthis.treeRoot = tree.root;\n\t}\n\n\tdisqualifyUser(user: TournamentPlayer) {\n\t\tif (!this.isBracketFrozen) return 'BracketNotFrozen';\n\n\t\t/**\n\t\t * The user either has a single available battle or no available battles\n\t\t */\n\t\tconst found = this.treeRoot.find(node => {\n\t\t\tif (node.state === 'available') {\n\t\t\t\tif (!node.children) throw new Error(`no children`);\n\t\t\t\tif (node.children[0].user === user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmatch: [user, node.children[1].user],\n\t\t\t\t\t\tresult: 'loss',\n\t\t\t\t\t\tscore: [0, 1],\n\t\t\t\t\t};\n\t\t\t\t} else if (node.children[1].user === user) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmatch: [node.children[0].user, user],\n\t\t\t\t\t\tresult: 'win',\n\t\t\t\t\t\tscore: [1, 0],\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t});\n\t\tif (found) {\n\t\t\t// @ts-expect-error TODO: refactor to fix this\n\t\t\tconst error = this.setMatchResult(found.match, found.result, found.score);\n\t\t\tif (error) {\n\t\t\t\tthrow new Error(`Unexpected ${error} from setMatchResult([${found.match.join(', ')}], ${found.result})`);\n\t\t\t}\n\t\t}\n\n\t\tuser.game.setPlayerUser(user, null);\n\t}\n\n\tgetAvailableMatches() {\n\t\tif (!this.isBracketFrozen) return 'BracketNotFrozen';\n\n\t\tconst matches: [TournamentPlayer, TournamentPlayer][] = [];\n\t\tthis.treeRoot.traverse(node => {\n\t\t\tif (node.state !== 'available') return;\n\t\t\tconst p1 = node.children![0].user!;\n\t\t\tconst p2 = node.children![1].user!;\n\t\t\tif (!p1.isBusy && !p2.isBusy) {\n\t\t\t\tmatches.push([p1, p2]);\n\t\t\t}\n\t\t});\n\t\treturn matches;\n\t}\n\tsetMatchResult([p1, p2]: [TournamentPlayer, TournamentPlayer], result: 'win' | 'loss', score: number[]) {\n\t\tif (!this.isBracketFrozen) return 'BracketNotFrozen';\n\n\t\tif (!['win', 'loss'].includes(result)) return 'InvalidMatchResult';\n\n\t\tif (!this.players.includes(p1) || !this.players.includes(p2)) return 'UserNotAdded';\n\n\t\tconst targetNode = this.treeRoot.find(node => {\n\t\t\tif (node.state === 'available' && (\n\t\t\t\tnode.children![0].user === p1 && node.children![1].user === p2\n\t\t\t)) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t\treturn undefined;\n\t\t});\n\t\tif (!targetNode) return 'InvalidMatch';\n\t\tif (!targetNode.children) throw new Error(`invalid available state`);\n\n\t\ttargetNode.state = 'finished';\n\t\ttargetNode.result = result;\n\t\ttargetNode.score = score.slice();\n\n\t\tconst winner = targetNode.children[result === 'win' ? 0 : 1].user;\n\t\tconst loser = targetNode.children[result === 'loss' ? 0 : 1].user;\n\t\ttargetNode.user = winner;\n\t\tif (!winner || !loser) throw new Error(`invalid available state`);\n\n\t\tif (loser.losses === this.maxSubtrees) {\n\t\t\tloser.isEliminated = true;\n\t\t\tloser.sendRoom(`|tournament|update|{\"isJoined\":false}`);\n\t\t\tloser.game.setPlayerUser(loser, null);\n\t\t}\n\n\t\tif (targetNode.parent) {\n\t\t\tconst parent = targetNode.parent;\n\n\t\t\tif (loser.losses <= winner.losses && !loser.isDisqualified) {\n\t\t\t\t// grand subfinals rematch\n\t\t\t\tconst newNode = new ElimNode({ state: 'available', losersBracketNode: targetNode.losersBracketNode });\n\t\t\t\tnewNode.setChildren([targetNode, new ElimNode({ user: loser })]);\n\t\t\t\tparent.setChildren([newNode, parent.children![1]]);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst userA = parent.children![0].user;\n\t\t\tconst userB = parent.children![1].user;\n\t\t\tif (userA && userB) {\n\t\t\t\tparent.state = 'available';\n\n\t\t\t\tlet error: string | undefined = '';\n\t\t\t\tif (userA.isDisqualified) {\n\t\t\t\t\terror = this.setMatchResult([userA, userB], 'loss', [0, 1]);\n\t\t\t\t} else if (userB.isDisqualified) {\n\t\t\t\t\terror = this.setMatchResult([userA, userB], 'win', [1, 0]);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthrow new Error(`Unexpected ${error} from setMatchResult([${userA},${userB}], ...)`);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (loser.losses < this.maxSubtrees && !loser.isDisqualified) {\n\t\t\tconst newRoot = new ElimNode({ state: 'available' });\n\t\t\tnewRoot.setChildren([targetNode, new ElimNode({ user: loser })]);\n\t\t\tthis.treeRoot = newRoot;\n\t\t}\n\n\t\tif (targetNode.losersBracketNode) {\n\t\t\ttargetNode.losersBracketNode.user = loser;\n\t\t\tconst userA = targetNode.losersBracketNode.parent!.children![0].user;\n\t\t\tconst userB = targetNode.losersBracketNode.parent!.children![1].user;\n\t\t\tif (userA && userB) {\n\t\t\t\ttargetNode.losersBracketNode.parent!.state = 'available';\n\n\t\t\t\tlet error: string | undefined = '';\n\t\t\t\tif (userA.isDisqualified) {\n\t\t\t\t\terror = this.setMatchResult([userA, userB], 'loss', [0, 1]);\n\t\t\t\t} else if (userB.isDisqualified) {\n\t\t\t\t\terror = this.setMatchResult([userA, userB], 'win', [1, 0]);\n\t\t\t\t}\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthrow new Error(`Unexpected ${error} from setMatchResult([${userA}, ${userB}], ...)`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisTournamentEnded() {\n\t\treturn this.treeRoot.state === 'finished';\n\t}\n\n\tgetResults() {\n\t\tif (!this.isTournamentEnded()) return 'TournamentNotEnded';\n\n\t\tconst results = [];\n\t\tlet currentNode = this.treeRoot;\n\t\tfor (let n = 0; n < this.maxSubtrees; ++n) {\n\t\t\tresults.push([currentNode.user]);\n\n\t\t\tif (!currentNode.children) break;\n\t\t\tcurrentNode = currentNode.children[currentNode.result === 'loss' ? 0 : 1];\n\t\t\tif (!currentNode) break;\n\t\t}\n\n\t\tif (this.players.length - 1 === this.maxSubtrees && currentNode) {\n\t\t\tresults.push([currentNode.user]);\n\t\t}\n\n\t\treturn results;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
