{
  "version": 3,
  "sources": ["../../sim/dex-data.ts"],
  "sourcesContent": ["/**\n * Dex Data\n * Pokemon Showdown - http://pokemonshowdown.com/\n *\n * @license MIT\n */\nimport { Utils } from '../lib/utils';\n\n/**\n* Converts anything to an ID. An ID must have only lowercase alphanumeric\n* characters.\n*\n* If a string is passed, it will be converted to lowercase and\n* non-alphanumeric characters will be stripped.\n*\n* If an object with an ID is passed, its ID will be returned.\n* Otherwise, an empty string will be returned.\n*\n* Generally assigned to the global toID, because of how\n* commonly it's used.\n*/\nexport function toID(text: any): ID {\n\tif (typeof text !== 'string') {\n\t\tif (text) text = text.id || text.userid || text.roomid || text;\n\t\tif (typeof text === 'number') text = `${text}`;\n\t\telse if (typeof text !== 'string') return '';\n\t}\n\treturn text.toLowerCase().replace(/[^a-z0-9]+/g, '') as ID;\n}\n\n/**\n * Like Object.assign but only assigns fields missing from self.\n * Facilitates consistent field ordering in constructors.\n * Modifies self in-place.\n */\nexport function assignMissingFields(self: AnyObject, data: AnyObject) {\n\tfor (const k in data) {\n\t\tif (k in self) continue;\n\t\tself[k] = data[k];\n\t}\n}\n\nexport abstract class BasicEffect implements EffectData {\n\t/**\n\t * ID. This will be a lowercase version of the name with all the\n\t * non-alphanumeric characters removed. So, for instance, \"Mr. Mime\"\n\t * becomes \"mrmime\", and \"Basculin-Blue-Striped\" becomes\n\t * \"basculinbluestriped\".\n\t */\n\tid: ID;\n\t/**\n\t * Name. Currently does not support Unicode letters, so \"Flab\u00E9b\u00E9\"\n\t * is \"Flabebe\" and \"Nidoran\u2640\" is \"Nidoran-F\".\n\t */\n\tname: string;\n\t/**\n\t * Full name. Prefixes the name with the effect type. For instance,\n\t * Leftovers would be \"item: Leftovers\", confusion the status\n\t * condition would be \"confusion\", etc.\n\t */\n\tfullname: string;\n\t/** Effect type. */\n\teffectType: EffectType;\n\t/**\n\t * Does it exist? For historical reasons, when you use an accessor\n\t * for an effect that doesn't exist, you get a dummy effect that\n\t * doesn't do anything, and this field set to false.\n\t */\n\texists: boolean;\n\t/**\n\t * Dex number? For a Pokemon, this is the National Dex number. For\n\t * other effects, this is often an internal ID (e.g. a move\n\t * number). Not all effects have numbers, this will be 0 if it\n\t * doesn't. Nonstandard effects (e.g. CAP effects) will have\n\t * negative numbers.\n\t */\n\tnum: number;\n\t/**\n\t * The generation of Pokemon game this was INTRODUCED (NOT\n\t * necessarily the current gen being simulated.) Not all effects\n\t * track generation; this will be 0 if not known.\n\t */\n\tgen: number;\n\t/**\n\t * A shortened form of the description of this effect.\n\t * Not all effects have this.\n\t */\n\tshortDesc: string;\n\t/** The full description for this effect. */\n\tdesc: string;\n\t/**\n\t * Is this item/move/ability/pokemon nonstandard? Specified for effects\n\t * that have no use in standard formats: made-up pokemon (CAP),\n\t * glitches (MissingNo etc), Pokestar pokemon, etc.\n\t */\n\tisNonstandard: Nonstandard | null;\n\t/** The duration of the condition - only for pure conditions. */\n\tduration?: number;\n\t/** Whether or not the condition is ignored by Baton Pass - only for pure conditions. */\n\tnoCopy: boolean;\n\t/** Whether or not the condition affects fainted Pokemon. */\n\taffectsFainted: boolean;\n\t/** Moves only: what status does it set? */\n\tstatus?: ID;\n\t/** Moves only: what weather does it set? */\n\tweather?: ID;\n\t/** ??? */\n\tsourceEffect: string;\n\n\tconstructor(data: AnyObject) {\n\t\tthis.name = Utils.getString(data.name).trim();\n\t\tthis.id = data.realMove ? toID(data.realMove) : toID(this.name); // Hidden Power hack\n\t\tthis.fullname = Utils.getString(data.fullname) || this.name;\n\t\tthis.effectType = Utils.getString(data.effectType) as EffectType || 'Condition';\n\t\tthis.exists = data.exists ?? !!this.id;\n\t\tthis.num = data.num || 0;\n\t\tthis.gen = data.gen || 0;\n\t\tthis.shortDesc = data.shortDesc || '';\n\t\tthis.desc = data.desc || '';\n\t\tthis.isNonstandard = data.isNonstandard || null;\n\t\tthis.duration = data.duration;\n\t\tthis.noCopy = !!data.noCopy;\n\t\tthis.affectsFainted = !!data.affectsFainted;\n\t\tthis.status = data.status as ID || undefined;\n\t\tthis.weather = data.weather as ID || undefined;\n\t\tthis.sourceEffect = data.sourceEffect || '';\n\t}\n\n\ttoString() {\n\t\treturn this.name;\n\t}\n}\n\nexport class Nature extends BasicEffect implements Readonly<BasicEffect & NatureData> {\n\toverride readonly effectType: 'Nature';\n\treadonly plus?: StatIDExceptHP;\n\treadonly minus?: StatIDExceptHP;\n\tconstructor(data: AnyObject) {\n\t\tsuper(data);\n\t\tthis.fullname = `nature: ${this.name}`;\n\t\tthis.effectType = 'Nature';\n\t\tthis.gen = 3;\n\t\tthis.plus = data.plus || undefined;\n\t\tthis.minus = data.minus || undefined;\n\t\tassignMissingFields(this, data);\n\t}\n}\n\nconst EMPTY_NATURE = Utils.deepFreeze(new Nature({ name: '', exists: false }));\n\nexport interface NatureData {\n\tname: string;\n\tplus?: StatIDExceptHP;\n\tminus?: StatIDExceptHP;\n}\n\nexport type ModdedNatureData = NatureData | Partial<Omit<NatureData, 'name'>> & { inherit: true };\n\nexport interface NatureDataTable { [natureid: IDEntry]: NatureData }\n\nexport class DexNatures {\n\treadonly dex: ModdedDex;\n\treadonly natureCache = new Map<ID, Nature>();\n\tallCache: readonly Nature[] | null = null;\n\n\tconstructor(dex: ModdedDex) {\n\t\tthis.dex = dex;\n\t}\n\n\tget(name: string | Nature): Nature {\n\t\tif (name && typeof name !== 'string') return name;\n\t\treturn this.getByID(toID(name));\n\t}\n\tgetByID(id: ID): Nature {\n\t\tif (id === '') return EMPTY_NATURE;\n\t\tlet nature = this.natureCache.get(id);\n\t\tif (nature) return nature;\n\n\t\tconst alias = this.dex.getAlias(id);\n\t\tif (alias) {\n\t\t\tnature = this.get(alias);\n\t\t\tif (nature.exists) {\n\t\t\t\tthis.natureCache.set(id, nature);\n\t\t\t}\n\t\t\treturn nature;\n\t\t}\n\t\tif (id && this.dex.data.Natures.hasOwnProperty(id)) {\n\t\t\tconst natureData = this.dex.data.Natures[id];\n\t\t\tnature = new Nature(natureData);\n\t\t\tif (nature.gen > this.dex.gen) nature.isNonstandard = 'Future';\n\t\t} else {\n\t\t\tnature = new Nature({ name: id, exists: false });\n\t\t}\n\n\t\tif (nature.exists) this.natureCache.set(id, this.dex.deepFreeze(nature));\n\t\treturn nature;\n\t}\n\n\tall(): readonly Nature[] {\n\t\tif (this.allCache) return this.allCache;\n\t\tconst natures = [];\n\t\tfor (const id in this.dex.data.Natures) {\n\t\t\tnatures.push(this.getByID(id as ID));\n\t\t}\n\t\tthis.allCache = Object.freeze(natures);\n\t\treturn this.allCache;\n\t}\n}\n\nexport interface TypeData {\n\tdamageTaken: { [attackingTypeNameOrEffectid: string]: number };\n\tHPdvs?: SparseStatsTable;\n\tHPivs?: SparseStatsTable;\n\tisNonstandard?: Nonstandard | null;\n}\n\nexport type ModdedTypeData = TypeData | Partial<Omit<TypeData, 'name'>> & { inherit: true };\nexport interface TypeDataTable { [typeid: IDEntry]: TypeData }\nexport interface ModdedTypeDataTable { [typeid: IDEntry]: ModdedTypeData }\n\ntype TypeInfoEffectType = 'Type' | 'EffectType';\n\nexport class TypeInfo implements Readonly<TypeData> {\n\t/**\n\t * ID. This will be a lowercase version of the name with all the\n\t * non-alphanumeric characters removed. e.g. 'flying'\n\t */\n\treadonly id: ID;\n\t/** Name. e.g. 'Flying' */\n\treadonly name: string;\n\t/** Effect type. */\n\treadonly effectType: TypeInfoEffectType;\n\t/**\n\t * Does it exist? For historical reasons, when you use an accessor\n\t * for an effect that doesn't exist, you get a dummy effect that\n\t * doesn't do anything, and this field set to false.\n\t */\n\treadonly exists: boolean;\n\t/**\n\t * The generation of Pokemon game this was INTRODUCED (NOT\n\t * necessarily the current gen being simulated.) Not all effects\n\t * track generation; this will be 0 if not known.\n\t */\n\treadonly gen: number;\n\t/**\n\t * Set to 'Future' for types before they're released (like Fairy\n\t * in Gen 5 or Dark in Gen 1).\n\t */\n\treadonly isNonstandard: Nonstandard | null;\n\t/**\n\t * Type chart, attackingTypeName:result, effectid:result\n\t * result is: 0 = normal, 1 = weakness, 2 = resistance, 3 = immunity\n\t */\n\treadonly damageTaken: { [attackingTypeNameOrEffectid: string]: number };\n\t/** The IVs to get this Type Hidden Power (in gen 3 and later) */\n\treadonly HPivs: SparseStatsTable;\n\t/** The DVs to get this Type Hidden Power (in gen 2). */\n\treadonly HPdvs: SparseStatsTable;\n\n\tconstructor(data: AnyObject) {\n\t\tthis.name = data.name;\n\t\tthis.id = data.id;\n\t\tthis.effectType = Utils.getString(data.effectType) as TypeInfoEffectType || 'Type';\n\t\tthis.exists = data.exists ?? !!this.id;\n\t\tthis.gen = data.gen || 0;\n\t\tthis.isNonstandard = data.isNonstandard || null;\n\t\tthis.damageTaken = data.damageTaken || {};\n\t\tthis.HPivs = data.HPivs || {};\n\t\tthis.HPdvs = data.HPdvs || {};\n\t\tassignMissingFields(this, data);\n\t}\n\n\ttoString() {\n\t\treturn this.name;\n\t}\n}\n\nconst EMPTY_TYPE_INFO = Utils.deepFreeze(new TypeInfo({ name: '', id: '', exists: false, effectType: 'EffectType' }));\n\nexport class DexTypes {\n\treadonly dex: ModdedDex;\n\treadonly typeCache = new Map<ID, TypeInfo>();\n\tallCache: readonly TypeInfo[] | null = null;\n\tnamesCache: readonly string[] | null = null;\n\n\tconstructor(dex: ModdedDex) {\n\t\tthis.dex = dex;\n\t}\n\n\tget(name: string | TypeInfo): TypeInfo {\n\t\tif (name && typeof name !== 'string') return name;\n\t\treturn this.getByID(toID(name));\n\t}\n\n\tgetByID(id: ID): TypeInfo {\n\t\tif (id === '') return EMPTY_TYPE_INFO;\n\t\tlet type = this.typeCache.get(id);\n\t\tif (type) return type;\n\n\t\tconst typeName = id.charAt(0).toUpperCase() + id.substr(1);\n\t\tif (typeName && this.dex.data.TypeChart.hasOwnProperty(id)) {\n\t\t\ttype = new TypeInfo({ name: typeName, id, ...this.dex.data.TypeChart[id] });\n\t\t} else {\n\t\t\ttype = new TypeInfo({ name: typeName, id, exists: false, effectType: 'EffectType' });\n\t\t}\n\n\t\tif (type.exists) this.typeCache.set(id, this.dex.deepFreeze(type));\n\t\treturn type;\n\t}\n\n\tnames(): readonly string[] {\n\t\tif (this.namesCache) return this.namesCache;\n\n\t\tthis.namesCache = this.all().filter(type => !type.isNonstandard).map(type => type.name);\n\n\t\treturn this.namesCache;\n\t}\n\n\tisName(name: string | null | undefined): boolean {\n\t\tif (!name) return false;\n\t\tconst id = name.toLowerCase();\n\t\tconst typeName = id.charAt(0).toUpperCase() + id.substr(1);\n\t\treturn name === typeName && this.dex.data.TypeChart.hasOwnProperty(id);\n\t}\n\n\tall(): readonly TypeInfo[] {\n\t\tif (this.allCache) return this.allCache;\n\t\tconst types = [];\n\t\tfor (const id in this.dex.data.TypeChart) {\n\t\t\ttypes.push(this.getByID(id as ID));\n\t\t}\n\t\tthis.allCache = Object.freeze(types);\n\t\treturn this.allCache;\n\t}\n}\n\nconst idsCache: readonly StatID[] = ['hp', 'atk', 'def', 'spa', 'spd', 'spe'];\nconst reverseCache: { readonly [k: IDEntry]: StatID } = {\n\t__proto: null as any,\n\t\"hitpoints\": 'hp',\n\t\"attack\": 'atk',\n\t\"defense\": 'def',\n\t\"specialattack\": 'spa', \"spatk\": 'spa', \"spattack\": 'spa', \"specialatk\": 'spa',\n\t\"special\": 'spa', \"spc\": 'spa',\n\t\"specialdefense\": 'spd', \"spdef\": 'spd', \"spdefense\": 'spd', \"specialdef\": 'spd',\n\t\"speed\": 'spe',\n};\nexport class DexStats {\n\treadonly shortNames: { readonly [k in StatID]: string };\n\treadonly mediumNames: { readonly [k in StatID]: string };\n\treadonly names: { readonly [k in StatID]: string };\n\tconstructor(dex: ModdedDex) {\n\t\tif (dex.gen !== 1) {\n\t\t\tthis.shortNames = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Atk\", def: \"Def\", spa: \"SpA\", spd: \"SpD\", spe: \"Spe\",\n\t\t\t} as any;\n\t\t\tthis.mediumNames = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Attack\", def: \"Defense\", spa: \"Sp. Atk\", spd: \"Sp. Def\", spe: \"Speed\",\n\t\t\t} as any;\n\t\t\tthis.names = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Attack\", def: \"Defense\", spa: \"Special Attack\", spd: \"Special Defense\", spe: \"Speed\",\n\t\t\t} as any;\n\t\t} else {\n\t\t\tthis.shortNames = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Atk\", def: \"Def\", spa: \"Spc\", spd: \"[SpD]\", spe: \"Spe\",\n\t\t\t} as any;\n\t\t\tthis.mediumNames = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Attack\", def: \"Defense\", spa: \"Special\", spd: \"[Sp. Def]\", spe: \"Speed\",\n\t\t\t} as any;\n\t\t\tthis.names = {\n\t\t\t\t__proto__: null, hp: \"HP\", atk: \"Attack\", def: \"Defense\", spa: \"Special\", spd: \"[Special Defense]\", spe: \"Speed\",\n\t\t\t} as any;\n\t\t}\n\t}\n\tgetID(name: string) {\n\t\tif (name === 'Spd') return 'spe' as StatID;\n\t\tconst id = toID(name);\n\t\tif (reverseCache[id]) return reverseCache[id];\n\t\tif (idsCache.includes(id as StatID)) return id as StatID;\n\t\treturn null;\n\t}\n\tids(): typeof idsCache {\n\t\treturn idsCache;\n\t}\n}\n"],
  "mappings": "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",
  "names": []
}
